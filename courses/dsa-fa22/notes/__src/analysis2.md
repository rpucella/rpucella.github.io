<script>
  document.title = 'Analysis of Algorithms (2)'
</script>


# Analysis of Algorithms (2)

## Divide-and-Conquer Algorithms

Last time, we saw a couple of loop-based in-place sorting algorithms with a <math><mrow><mrow><mi mathvariant="normal">Θ</mi></mrow><mo form="prefix" stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo form="postfix" stretchy="false">)</mo></mrow></math> running time. Turns out we can do better, but we need a new technique.

*Divide-and-conquer* is an algorithmic design technique with the following general shape:

1. Given a problem instance
2. Split the instance into smaller problem instances
3. Solve those smaller problem instances
4. Combine the results of solving the smaller instances into a solution for the original instance.

Divide-and-conquer is a useful technique to use when there is a natural way to break up the problem in pieces in such a way that it's possible to construct a solution from the solutions of the smaller pieces. The latter is key, and not always possible.

How do you solve the smaller instances into which you broke up the original instance? By invoking the algorithm itself, recursively. In order for that to terminate, it needs to be the case that eventually the problem gets small enough that it is trivial to solve.


## Sorting: Merge Sort

We can apply divide-and-conquer to sorting as follows: 

1. Given a sequence of integers
2. Split the sequence into two subsequences of roughly equal size
3. Sort each subsequence
4. Merge the two subsequences into a single sequence

The resulting algorithm is called Merge Sort. For step 2, it doesn't matter how we split the sequence. If it is presented as an array, we can split it into the left half and the right half. Step 4, mergine two sorted sequences, is easy: step through each sequence in paralle, from smaller to larger value, pulling in at every step the smaller value between the two sequences. You only need a single pass over both sequence, from left to right.

You can almost do this in place. By defining a subsequence of the array as a "subarray" using a pair of indices of where the subsequence starts and where it ends in the array, you can "split" the array by simply choosing indices appropriately. Merging two subarrays unfortunately cannot be done in place: you need an auxiliary array into which you build the final sorted merged sequence, which you can then copy back into the original array.

The core of the algorith is a routine `MSORT` that applies Merge Sort to a subarray of a larger array:

    MERGE-SORT(a = <a_1, ...., a_n>) =
    MSORT(A, 1, n)

    MSORT(A = <a_1, ..., a_n>, i, j) =
    if i = j
       done
    else
       mid = ceiling((i - j) / 2) + i
       MSORT(A, i, mid)
       MSORT(A, mid + 1, j)
       MERGE(A, i, mid, j)

Routine `MERGE` takes an array `A` and *sorted* subarrays `A[i .. mid]` and `A[mid+1 .. j]` and merges the two subarrays by scanning then from left to right in parallel, putting the smallest value found at every step into a temporary array, and then copying the sorted values in that temporary array back into `A[i .. j]`. The details of this algorithm are left to the homework.


## Running Time of Recursive Algorithms


So how do we analyze recursive algorithms? At the end of the day, it's still about counting how many steps the algorithms take to get its result, but we don't necessarily have loops to work with. (We may, but we may not.) More importantly, we have recursive routine calls.

Generally, a routine call doesn't take just one step, but it takes however many steps the routine itself takes on its input. 

Let's use T(n) to be the running time of Merge Sort on input of size n, `T_MSORT(n)` for the running time of MSORT on an input of size n (that is, a subarray of size n), and `T_MERGE` for the running time of MERGE on an input of size n (that is, two subarrays totaling size n). 

    MERGE-SORT(A) =
    MSORT(A, i, n)                         T_MSORT(n)
    
    MSORT(A = <a_1, ..., a_n>, i, j) =
    if i = j                               1
       done                                1
    else
       mid = ceiling((i - j) / 2) + i      1
       MSORT(A, i, mid)                    T_MSORT((j-i+1)/2)
       MSORT(A, mid + 1, j)                T_MSORT((j-i+1)/2)
       MERGE(A, i, mid, j)                 T_MERGE(j-i+1)

Routine `MERGE`, if done in the obvious way, has running time `T_MERGE(n) = Kn` for some constant `K` that will not really matter.

Note that `T(n) = T_MSORT(n)` for all n, so let's just use `T(n)` in lieu of `T_MSORT(n)`.

The most natural way to write down `T(n)` is to express it in terms of `T` itself, because of the recursive routine call. This gives us the following *recurrence equation* defining `T(n)`:

<math display="block"><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true" form="prefix">{</mo><mtable rowspacing="0.16em" columnalign="left left" columnspacing="1em" class="tml-array"><mtr><mtd style="text-align:-webkit-left;"><mrow><mtext> </mtext><mtext> </mtext><mn>2</mn></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mtext>i</mtext><mtext>f</mtext><mtext> </mtext><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mtext> </mtext><mtext>o</mtext><mtext>r</mtext><mtext> </mtext><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-left;"><mrow><mtext> </mtext><mtext> </mtext><mn>2</mn><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo lspace="0em" rspace="0em">⁄</mo><mn>2</mn><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mi>K</mi><mi>n</mi><mo>+</mo><mn>2</mn></mrow></mtd><mtd style="text-align:-webkit-left;"><mtext>otherwise</mtext></mtd></mtr></mtable><mo fence="true" form="postfix"></mo></mrow></mrow></math>

How do we solve this? That is, how do we find a closed form for <math><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo></mrow></math>? We can get some intuition for what <math><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> might be by expanding out <math><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> for various values of <math><mi>n</mi></math>. Because we're going to repeatedly divide by 2, let's focus on `n` being a power of 2, and I'll will try to make variable <math><mi>n</mi></math> explicit where it makes sense because I want us to track the relationship between the result we get and <math><mi>n</mi></math>:

<math display="block"><mtable displaystyle="true" rowspacing="0.25em" columnalign="right left" columnspacing="0em" class="tml-array tml-gather"><mtr><mtd style="text-align:-webkit-right;"><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mo>=</mo><mn>2</mn></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mn>2</mn><mo form="postfix" stretchy="false">)</mo></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mo>=</mo><mn>2</mn><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo lspace="0em" rspace="0em">⁄</mo><mn>2</mn><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>K</mi><mo>+</mo><mn>2</mn><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext>w</mtext><mtext>h</mtext><mtext>e</mtext><mtext>r</mtext><mtext>e</mtext><mtext> </mtext><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow></mrow></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mo>=</mo><mn>2</mn><mo form="prefix" stretchy="false">(</mo><mn>2</mn><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>K</mi><mo>+</mo><mn>2</mn></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mo>=</mo><mn>4</mn><mo>+</mo><mi>n</mi><mi>K</mi><mo>+</mo><mn>2</mn></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mn>4</mn><mo form="postfix" stretchy="false">)</mo></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mo>=</mo><mn>2</mn><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo lspace="0em" rspace="0em">⁄</mo><mn>2</mn><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>K</mi><mo>+</mo><mn>2</mn><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext>w</mtext><mtext>h</mtext><mtext>e</mtext><mtext>r</mtext><mtext>e</mtext><mtext> </mtext><mrow><mi>n</mi><mo>=</mo><mn>4</mn></mrow></mrow></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mo>=</mo><mn>2</mn><mo form="prefix" stretchy="false">(</mo><mn>4</mn><mo>+</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mi>K</mi><mo>+</mo><mn>2</mn><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>K</mi><mo>+</mo><mn>2</mn></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mo>=</mo><mn>8</mn><mo>+</mo><mi>n</mi><mi>K</mi><mo>+</mo><mn>4</mn><mo>+</mo><mi>n</mi><mi>K</mi><mo>+</mo><mn>2</mn></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mo>=</mo><mn>8</mn><mo>+</mo><mn>2</mn><mi>n</mi><mi>K</mi><mo>+</mo><mn>6</mn></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mn>8</mn><mo form="postfix" stretchy="false">)</mo></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mo>=</mo><mn>2</mn><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo lspace="0em" rspace="0em">⁄</mo><mn>2</mn><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>K</mi><mo>+</mo><mn>2</mn><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext>w</mtext><mtext>h</mtext><mtext>e</mtext><mtext>r</mtext><mtext>e</mtext><mtext> </mtext><mrow><mi>n</mi><mo>=</mo><mn>8</mn></mrow></mrow></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mo>=</mo><mn>2</mn><mo form="prefix" stretchy="false">(</mo><mn>8</mn><mo>+</mo><mn>2</mn><mfrac><mi>n</mi><mn>2</mn></mfrac><mi>K</mi><mo>+</mo><mn>6</mn><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>K</mi><mo>+</mo><mn>2</mn></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mo>=</mo><mn>16</mn><mo>+</mo><mn>2</mn><mi>n</mi><mi>K</mi><mo>+</mo><mn>12</mn><mo>+</mo><mi>n</mi><mi>K</mi><mo>+</mo><mn>2</mn></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mo>=</mo><mn>16</mn><mo>+</mo><mn>3</mn><mi>n</mi><mi>K</mi><mo>+</mo><mn>14</mn></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mn>16</mn><mo form="postfix" stretchy="false">)</mo></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mo>=</mo><mn>2</mn><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo lspace="0em" rspace="0em">⁄</mo><mn>2</mn><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>K</mi><mo>+</mo><mn>2</mn><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext>w</mtext><mtext>h</mtext><mtext>e</mtext><mtext>r</mtext><mtext>e</mtext><mtext> </mtext><mrow><mi>n</mi><mo>=</mo><mn>16</mn></mrow></mrow></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mn>2</mn><mo form="prefix" stretchy="false">(</mo><mn>16</mn><mo>+</mo><mn>3</mn><mfrac><mi>n</mi><mn>2</mn></mfrac><mi>K</mi><mo>+</mo><mn>14</mn><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>K</mi><mo>+</mo><mn>2</mn></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mn>32</mn><mo>+</mo><mn>3</mn><mi>n</mi><mi>K</mi><mo>+</mo><mn>28</mn><mo>+</mo><mi>n</mi><mi>K</mi><mo>+</mo><mn>2</mn></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mn>32</mn><mo>+</mo><mn>4</mn><mi>n</mi><mi>K</mi><mo>+</mo><mn>30</mn></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mn>32</mn><mo form="postfix" stretchy="false">)</mo></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mo>=</mo><mn>2</mn><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo lspace="0em" rspace="0em">⁄</mo><mn>2</mn><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>K</mi><mo>+</mo><mn>2</mn><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext>w</mtext><mtext>h</mtext><mtext>e</mtext><mtext>r</mtext><mtext>e</mtext><mtext> </mtext><mrow><mi>n</mi><mo>=</mo><mn>32</mn></mrow></mrow></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow></mrow></mtd><mtd style="text-align:-webkit-left;"><mo lspace="0em" rspace="0em">…</mo></mtd></mtr></mtable></math>

We could keep going, and the pattern emerges:

<math display="block"><mtable displaystyle="true" rowspacing="0.25em" columnalign="right left right" columnspacing="0em 1em" class="tml-array tml-gather"><mtr><mtd style="text-align:-webkit-right;"><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><msup><mn>2</mn><mi>m</mi></msup><mo form="postfix" stretchy="false">)</mo></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mo>=</mo><mn>2</mn><mo form="prefix" stretchy="false">(</mo><msup><mn>2</mn><mi>m</mi></msup><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mi>m</mi><mo form="prefix" stretchy="false">(</mo><msup><mn>2</mn><mi>m</mi></msup><mo form="postfix" stretchy="false">)</mo><mi>K</mi><mo>+</mo><mn>2</mn><mo form="prefix" stretchy="false">(</mo><msup><mn>2</mn><mi>m</mi></msup><mo form="postfix" stretchy="false">)</mo><mo>−</mo><mn>2</mn></mrow></mtd><mtd style="text-align:-webkit-right;"><mrow><mo>=</mo><mi>m</mi><mo form="prefix" stretchy="false">(</mo><msup><mn>2</mn><mi>m</mi></msup><mo form="postfix" stretchy="false">)</mo><mi>K</mi><mo>+</mo><mn>4</mn><mo form="prefix" stretchy="false">(</mo><msup><mn>2</mn><mi>m</mi></msup><mo form="postfix" stretchy="false">)</mo><mo>−</mo><mn>2</mn></mrow></mtd></mtr></mtable></math>
In other words:
<math display="block"><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mi>K</mi><mi>n</mi><mspace width="0.1667em"></mspace><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mi>n</mi><mo>+</mo><mn>4</mn><mi>n</mi><mo>−</mo><mn>2</mn></mrow></math>
which one can check is <math><mrow><mrow><mi mathvariant="normal">Θ</mi></mrow><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mspace width="0.1667em"></mspace><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo></mrow></math>

There are a few more systematic ways of finding solutions to recurrence equations. I will point you to the textbook for them. Gues and verify (aka, the substitution method) is probably the most useful. When applicable, generic results simplofy the task. For example, a result the textbook calls *the master method* is useful when your recurrence equation takes the following form:

<math display="block"><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo lspace="0em" rspace="0em">⁄</mo><mi>b</mi><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo></mrow></math>

(with some <math><mrow><mi>a</mi><mo>≥</mo><mn>1</mn></mrow></math> and <math><mrow><mi>b</mi><mo>&gt;</mo><mn>1</mn></mrow></math> and where T(0) and T(1) are constants).

The resulting solution will depend on whether <math><mrow><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> grows like <math><msup><mi>n</mi><mrow><msub><mi>log</mi><mi>b</mi></msub><mo>⁡</mo><mi>a</mi></mrow></msup></math>, or slower, or faster:

- if <math><mrow><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> is <math><mrow><mi>O</mi><mo form="prefix" stretchy="false">(</mo><msup><mi>n</mi><mrow><msub><mi>log</mi><mi>b</mi></msub><mo>⁡</mo><mi>a</mi><mo>−</mo><mi>ϵ</mi></mrow></msup><mo form="postfix" stretchy="false">)</mo></mrow></math>, that is, <math><mrow><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> grows slower than <math><msup><mi>n</mi><mrow><msub><mi>log</mi><mi>b</mi></msub><mo>⁡</mo><mi>a</mi></mrow></msup></math>, then <math><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo><mo>∈</mo><mrow><mi mathvariant="normal">Θ</mi></mrow><mo form="prefix" stretchy="false">(</mo><msup><mi>n</mi><mrow><msub><mi>log</mi><mi>b</mi></msub><mo>⁡</mo><mi>a</mi></mrow></msup><mo form="postfix" stretchy="false">)</mo></mrow></math>
- if <math><mrow><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> is <math><mrow><mrow><mi mathvariant="normal">Θ</mi></mrow><mo form="prefix" stretchy="false">(</mo><msup><mi>n</mi><mrow><msub><mi>log</mi><mi>b</mi></msub><mo>⁡</mo><mi>a</mi></mrow></msup><mo form="postfix" stretchy="false">)</mo></mrow></math>, then <math><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo><mo>∈</mo><mrow><mi mathvariant="normal">Θ</mi></mrow><mo form="prefix" stretchy="false">(</mo><msup><mi>n</mi><mrow><msub><mi>log</mi><mi>b</mi></msub><mo>⁡</mo><mi>a</mi></mrow></msup><msub><mi>log</mi><mi>b</mi></msub><mo>⁡</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo></mrow></math>
- if <math><mrow><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> is <math><mrow><mrow><mi mathvariant="normal">Ω</mi></mrow><mo form="prefix" stretchy="false">(</mo><msup><mi>n</mi><mrow><msub><mi>log</mi><mi>b</mi></msub><mo>⁡</mo><mi>a</mi><mo>+</mo><mi>ϵ</mi></mrow></msup><mo form="postfix" stretchy="false">)</mo></mrow></math>, that is, <math><mrow><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> grows faster than <math><msup><mi>n</mi><mrow><msub><mi>log</mi><mi>b</mi></msub><mo>⁡</mo><mi>a</mi></mrow></msup></math>, then <math><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo><mo>∈</mo><mrow><mi mathvariant="normal">Θ</mi></mrow><mo form="prefix" stretchy="false">(</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false">)</mo></mrow></math>.

For Merge Sort, the recurrence has the right form for this result, taking <math><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mo>=</mo><mn>2</mn></mrow></math> and <math><mrow><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mi>K</mi><mi>n</mi><mo>+</mo><mn>2</mn></mrow></math> for some constant <math><mi>K</mi></math>, yielding that <math><mrow><mi>T</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo><mo>∈</mo><mrow><mi mathvariant="normal">Θ</mi></mrow><mo form="prefix" stretchy="false">(</mo><msup><mi>n</mi><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mn>2</mn></mrow></msup><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mrow><mi mathvariant="normal">Θ</mi></mrow><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mspace width="0.1667em"></mspace><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> as we intuited.


## Correctness

We've talked about algorithms and developed few examples of algorithms for solving the sorting problem. But how do we know those algorithms are correct?

Correctness is important. If you don't care about correctness, you can come up with very fast algorithms that return the wrong answer. That's hardly useful.

There are many ways of establishing correctness of algorithms. Ultimately, they all amount to constructing a mathematical proof, either informally or formally.

Correctness basically says that an algorithm meets its specification. The way we defined algorithms are solving problems, an algorithm is correct if given as input an instance of the problem to solve, it produces the output that the definition of the problem demands for that input.

I will illustrate establishing correctness somewhat informally using two techniques that are most commonly used: one for looping algorithms, one for recursive algorithms. (Roughly matching the split we made for analyzing algorithms.)

Let's start with a simple example. Consider the problem of determing the smallest number in a sequence. The problem can be defined formally as:

    input: a sequence <a_1, ..., a_n>
    output: a value a in {a_1, ..., a_n} such that a <= a_1, ..., a_n

There is a perfectly straightforward algorthm for solving that problem:

    MINIMUM(A = <a_1, ..., a_n>) =
    min = A[1]
    for i = 2 to n
       if A[i] < min
          min = A[i]
    return min

This is a looping algorithm. The way to reason about looping algorithms is to use a *loop
invariant*. Intuitively, a loop invariant is a property that is true before the loop executes, and
that remains true at every iteration of the loop. Formally, <math><mi>P</mi></math> is a loop invariant if:

1. <math><mi>P</mi></math> holds right before the first iteration of the loop.
2. Whenever <math><mi>P</mi></math> holds at the start of an iteration, then <math><mi>P</mi></math> holds at the start of the next iteration.

A loop invariant will generally refer to the loop variable, making the invariant sensitive to the iteration at hand.

A loop invariant is useful because once you have a loop invariant, you can conclude that the loop
invariant holds after the final iteration of the loop. If choose your loop invariant correctly, then
the loop invariant being true after the loop executes can match the specification that you are
trying to establish for the algorithm.

For the MINIMUM algorithm, we can take the following invariant — I am making the dependency on the loop variable explicit:

<math display="block"><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo form="postfix" stretchy="false">)</mo><mo>≡</mo><mrow><mtext>𝚖𝚒𝚗</mtext><mtext> </mtext><mtext>i</mtext><mtext>s</mtext><mtext> </mtext><mtext>t</mtext><mtext>h</mtext><mtext>e</mtext><mtext> </mtext><mtext>m</mtext><mtext>i</mtext><mtext>n</mtext><mtext>i</mtext><mtext>m</mtext><mtext>u</mtext><mtext>m</mtext><mtext> </mtext><mtext>v</mtext><mtext>a</mtext><mtext>l</mtext><mtext>u</mtext><mtext>e</mtext><mtext> </mtext><mtext>a</mtext><mtext>m</mtext><mtext>o</mtext><mtext>n</mtext><mtext>g</mtext><mtext> </mtext><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow></mrow></mrow></math>

To establish that <math><mi>P</mi></math> is a loop invariant, we need to check the two conditions.

- Right before the first iteration, <math><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow></math>, and <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mn>2</mn><mo form="postfix" stretchy="false">)</mo></mrow></math> says that `min` is the minimum value in <math><msub><mi>a</mi><mn>1</mn></msub></math>, which is true because `min` is initialized to be <math><msub><mi>a</mi><mn>1</mn></msub></math>.
- For iteration <math><mi>i</mi></math>, suppose that <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> holds, that is, `min` is the minimum value among <math><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow></math>. We need to show that <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow></math> holds after the iteration. Since the body of the loop is a conditional, there are two possibilities. One possibility is that <math><msub><mi>a</mi><mi>i</mi></msub></math> is less than `min` at the start of the iteration. In this case, `min` becomes <math><msub><mi>a</mi><mi>i</mi></msub></math>, and since `min` was less than <math><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow></math> by assumption, and `min` is less than <math><msub><mi>a</mi><mi>i</mi></msub></math> after the iteration, then <math><mrow><mtext>𝚖𝚒𝚗</mtext><mo>≤</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>i</mi></msub></mrow></math>, that is, <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow></math> holds. The other possibility is that <math><msub><mi>a</mi><mi>i</mi></msub></math> is not less than `min` at the start of the iteration, so that <math><mrow><mtext>𝚖𝚒𝚗</mtext><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub></mrow></math>, and since <math><mrow><mtext>𝚖𝚒𝚗</mtext><mo>≤</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></math> by assumption, we have that <math><mrow><mtext>𝚖𝚒𝚗</mtext><mo>≤</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>i</mi></msub></mrow></math>, that is, <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow></math> holds.

Therefore, <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> is a loop invariant. Which means that <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow></math> holds after the loop is done. (We are one past the last iteration.) In other words, `min` is less than or equal to <math><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow></math>, as required by the specification of the Minomum problem.

Lets use loop invariants to show that Bubble Sort correctly sorts a sequence of integers. Recall Bubble Sort:

    BUBBLE-SORT(A = <a_1, ..., a_n>) =           
    for i <- 1 to n-1
       for j <- n-1 to i
          if A[j] > A[j+1]
             temp = A[j]
             A[j] = A[j+1]
             A[j+1] = temp
	  
The specification for the sorting problem can be written as: on input <math><mrow><mo form="prefix" stretchy="false">⟨</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>d</mi><mi>o</mi><mi>t</mi><mi>s</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo form="postfix" stretchy="false">⟩</mo></mrow></math>, the output should be a permutation <math><mrow><mo form="prefix" stretchy="false">⟨</mo><msub><mi>a</mi><msub><mi>i</mi><mn>1</mn></msub></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><msub><mi>i</mi><mi>n</mi></msub></msub><mo form="postfix" stretchy="false">⟩</mo></mrow></math> such that <math><mrow><msub><mi>a</mi><msub><mi>i</mi><mn>1</mn></msub></msub><mo>≤</mo><mo>⋯</mo><mo>≤</mo><msub><mi>a</mi><msub><mi>i</mi><mi>n</mi></msub></msub></mrow></math>. In our case, the sequence is given in an array, and the output will be in that same array with its elements re-ordered.

We have two loops in the algorithms, so we'll have two loop invariants (one invariant per loop). The invariants should roughly capture our understanding of what the role of each loop is. The outer loop (over `i`) goes from the beginning of the array to the end of the array, making sure everything before position `i` is sorted and everything after position `i` is larger than everything before `i`, while the outer loop (over `j`) goes down from the end of the array, bubbling the smallest value after position `i` down to position `i`. Here are the corresponding invariant, <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> and <math><mrow><mi>Q</mi><mo form="prefix" stretchy="false">(</mo><mi>j</mi><mo form="postfix" stretchy="false">)</mo></mrow></math>. (Invariant <math><mi>Q</mi></math> for the inner loop technically depends on both indices, but <math><mi>i</mi></math> turns out not to be used.)

<math display="block"><mtable displaystyle="true" rowspacing="0.25em" columnalign="right left" columnspacing="0em" class="tml-array tml-gather"><mtr><mtd style="text-align:-webkit-right;"><mrow></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo form="postfix" stretchy="false">)</mo><mo>≡</mo><mrow><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo></mrow><mtext> </mtext><mtext>a</mtext><mtext>n</mtext><mtext>d</mtext><mtext> </mtext><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo form="postfix" stretchy="false">]</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>n</mi><mo form="postfix" stretchy="false">]</mo></mrow><mtext> </mtext><mtext>w</mtext><mtext>h</mtext><mtext>e</mtext><mtext>n</mtext><mtext> </mtext><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mtext> </mtext><mtext>e</mtext><mtext>x</mtext><mtext>i</mtext><mtext>s</mtext><mtext>t</mtext><mtext>s</mtext></mrow></mrow></mtd></mtr><mtr><mtd style="text-align:-webkit-right;"><mrow></mrow></mtd><mtd style="text-align:-webkit-left;"><mrow><mi>Q</mi><mo form="prefix" stretchy="false">(</mo><mi>j</mi><mo form="postfix" stretchy="false">)</mo><mo>≡</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>2</mn><mo form="postfix" stretchy="false">]</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>n</mi><mo form="postfix" stretchy="false">]</mo></mrow></mtd></mtr></mtable></math>

Once we establish that <math><mi>P</mi></math> is a loop invariant for the outer loop, we will be able to conclude that <math><mi>P</mi></math> holds after the last iteration of the loop, meaning that <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> (one past the last iteration index) will hold at the end of Bubble Sort. And <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> says that <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mo>…</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>n</mi><mo form="postfix" stretchy="false">]</mo></mrow></math>, that is, the array is sorted, which is our desired correctness condition.

So let's establish that <math><mi>P</mi></math> is a loop invariant.

- Right before the first iteration, <math><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow></math>, and <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow></math> requires that everything before position 1 (i.e., nothing) is ordered (which it is, vacuuously), and that everything before position 1 (i.e., nothing) is smaller than everything at position 1 and higher (which it is, vacuuously). So <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow></math> holds.
- For iteration  <math><mi>i</mi></math>, suppose that <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> holds, that is, <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mo>⋯</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo></mrow></math> and <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo form="postfix" stretchy="false">]</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>n</mi><mo form="postfix" stretchy="false">]</mo></mrow></math> when position <math><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></math> exists. What happens after the iteration? Well, we run the inner loop. Once we have that <math><mi>Q</mi></math> is a loop invariant of the inner loop, then we know that <math><mrow><mi>Q</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow></math> (one past the end of the inner loop) will hold after the inner loop concludes. And <math><mrow><mi>Q</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow></math> says that <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>n</mi><mo form="postfix" stretchy="false">]</mo></mrow></math>. So we have by assumptionn that <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mo>⋯</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo></mrow></math> and that <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo form="postfix" stretchy="false">]</mo></mrow></math>, and by <math><mrow><mi>Q</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow></math> we get that <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>n</mi><mo form="postfix" stretchy="false">]</mo></mrow></math>, which gives us that <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mo>⋯</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo form="postfix" stretchy="false">]</mo><mtext> </mtext></mrow></math> and <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>n</mi><mo form="postfix" stretchy="false">]</mo></mrow></math> which is exactly <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow></math>, as required.

So once we show that <math><mi>Q</mi></math> is a loop invariant of the inner loop, then we'll have that <math><mi>P</mi></math> is a loop invariant of the outer loop. Let's show that <math><mi>Q</mi></math> is a loop invariant. We'll show it for an arbitrary outer loop index `i`.

- Right before the first iteration of the inner loop, <math><mrow><mi>j</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow></math>, and <math><mrow><mi>Q</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow></math> requires that <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>n</mi><mo form="postfix" stretchy="false">]</mo></mrow></math> be less than anything in higher position, but there is nothing in higher position, so the result is vacuuously true, and <math><mrow><mi>Q</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow></math> holds.
- For iteration <math><mi>j</mi></math>, suppose that <math><mrow><mi>Q</mi><mo form="prefix" stretchy="false">(</mo><mi>j</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> holds, that is, <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>2</mn><mo form="postfix" stretchy="false">]</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>n</mi><mo form="postfix" stretchy="false">]</mo></mrow></math>. There are two possibilities for that iteration. The first possibility is that <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo form="postfix" stretchy="false">]</mo><mo>&gt;</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo></mrow></math>. In this case, we swap the content of position <math><mi>j</mi></math> and position <math><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></math>, so that after the swap we have <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo form="postfix" stretchy="false">]</mo><mo>&lt;</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo></mrow></math>, and by assumption, <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo form="postfix" stretchy="false">]</mo></mrow></math> (i.e., the old <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo></mrow></math>) is <math><mrow><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>2</mn><mo form="postfix" stretchy="false">]</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>n</mi><mo form="postfix" stretchy="false">]</mo></mrow></math>. So after the swap, we have <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>n</mi><mo form="postfix" stretchy="false">]</mo></mrow></math>. The second possibility is that <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo></mrow></math>, in which case we do not swap, but then by assumption we have that <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>2</mn><mo form="postfix" stretchy="false">]</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>n</mi><mo form="postfix" stretchy="false">]</mo></mrow></math>, so that <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>n</mi><mo form="postfix" stretchy="false">]</mo></mrow></math> as well. In both cases, we have <math><mrow><mi>Q</mi><mo form="prefix" stretchy="false">(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow></math> holding, as required.

So this shows that <math><mi>Q</mi></math> is a loop invariant, which implies that <math><mi>P</mi></math> is a loop invariant, which implies that Bubble Sort is correct.

Loop invariants work well when the algorithm is loop-driven. What about divide-and-conquer
algorithms, or more generally recursive algorithms? Instead of loop invariants, we use induction.

Induction is a way to prove properties about structures that are built out of smaller versions of the same structures. The natural numbers is the prototypical structure over which we use induction: to show property <math><mi>P</mi></math> holds for all natural number, it suffices to (1) show that <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mn>0</mn></mrow></math> holds, and (2) for all <math><mrow><mi>n</mi><mo>&gt;</mo><mn>0</mn></mrow></math>, whenever <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> holds for all <math><mrow><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow></math>, then <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>n</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> holds. (This is a form of induction called strong induction, which is the form most useful for correctness.
)

Consider the problem of getting the sum of the elements in an array, with input an array <math><mrow><mi>A</mi><mo>=</mo><mo form="prefix" stretchy="false">⟨</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mo form="postfix" stretchy="false">⟩</mo></mrow></math> and output <math><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>a</mi><mi>n</mi></msub></mrow></math>.

Consider the following simple (but artificial) algorithm to recursively solve this problem:

    SUM(A = <a_1, ..., a_n>) =
    SUM_TO(A, n)
    
    SUM_TO(A = <a_1, ..., a_n>, k) = 
    if k > n 
       error
    else if k = 0
       return 0
    else
       rest = SUM_TO(A, k-1)
       return A[k] + rest

The property we need is <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>k</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> which says that `SUM_TO(A, k)` yields <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>k</mi><mo form="postfix" stretchy="false">]</mo></mrow></math> whenever <math><mrow><mi>k</mi><mo>≤</mo><mi>n</mi></mrow></math>. (We don't care what happens when <math><mrow><mi>k</mi><mo>&gt;</mo><mi>n</mi></mrow></math>.) We show <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>k</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> holds for all <math><mrow><mi>k</mi><mo>≥</mo><mn>0</mn></mrow></math> by induction on input <math><mi>k</mi></math>.

- Since `SUM_TO(A, 0)` returns 0, then <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mn>0</mn><mo form="postfix" stretchy="false">)</mo></mrow></math> holds.
- Given <math><mrow><mi>k</mi><mo>&gt;</mo><mn>0</mn></mrow></math>, assume <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> is true for all <math><mrow><mi>i</mi><mo>&lt;</mo><mi>k</mi></mrow></math>. Suppose further that <math><mrow><mi>k</mi><mo>≤</mo><mi>n</mi></mrow></math>. Then `SUM_TO(A, k)` is `A[k] + rest`, where `rest` is `SUM_TO(A, k-1)`. Since <math><mrow><mi>k</mi><mo>−</mo><mn>1</mn><mo>&lt;</mo><mi>k</mi></mrow></math>, we know by assumption that `SUM_TO(A, k-1)` is <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo></mrow></math>. Therefore, `SUM_TO(A, k)` is <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>k</mi><mo form="postfix" stretchy="false">]</mo><mo>+</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo></mrow></math> = <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>k</mi><mo form="postfix" stretchy="false">]</mo></mrow></math>, that is, <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>k</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> holds.

Therefore, <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>k</mi><mo form="postfix" stretchy="false">)</mo></mrow></math> is true for all <math><mrow><mi>k</mi><mo>≥</mo><mn>0</mn></mrow></math>, meaning that `SUM_TO(A, k)` is <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>k</mi><mo form="postfix" stretchy="false">]</mo></mrow></math> for all <math><mrow><mi>k</mi><mo>≤</mo><mi>n</mi></mrow></math>. Since `SUM(A) = SUM_TO(A, n)`, we get that `SUM(A)` is <math><mrow><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>n</mi><mo form="postfix" stretchy="false">]</mo></mrow></math>, and `SUM` is correct with respect to its problem definition.

I will leave establishing the correctness of Merge Sort as a (somewhat challenging depending on your comfort level with induction) exercise. Here are the properties to be proved by induction. For `MSORT(A, i, j)`, we can use <math><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo form="postfix" stretchy="false">)</mo><mo>≡</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mo>⋯</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo form="postfix" stretchy="false">]</mo></mrow></math>, where induction is over the difference <math><mrow><mi>j</mi><mo>−</mo><mi>i</mi></mrow></math> (which goes down to 0 as <math><mi>i</mi></math> and <math><mi>j</mi></math> grow closer). For `MERGE(A, i, k, j)`, similarly, we can use <math><mrow><mi>Q</mi><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo form="postfix" stretchy="false">)</mo><mo>≡</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">]</mo><mo>≤</mo><mo>⋯</mo><mo>≤</mo><mi>A</mi><mo form="prefix" stretchy="false">[</mo><mi>j</mi><mo form="postfix" stretchy="false">]</mo></mrow></math>, where induction is again over the difefrence <math><mrow><mi>j</mi><mo>−</mo><mi>i</mi></mrow></math>.

