<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Riccardo Pucella</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="/static/main.css" type="text/css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    
  <style type="text/css">
     code { 
      white-space: pre;
     }

     body { 
       font-family: sans-serif;
       margin: 24px;
       line-height: 1.2;
       font-size: 16px;
     }

     hr, h2, h3, h4, h5, h6 {
         margin-top: 24px;
     }

     pre { 
         margin-left: 32px;
         color: blue;
     }
  </style>

  </head>


  <body>
  
    <script>
  document.title = 'Final Project - FOCS FA23'
</script>

<h1>Final Project</h1>

<h2>Due Date for deliverables: Sunday, Dec 17, 2023</h2>

<p>Think of the final project as a more open-ended last homework with an associated short presentation.</p>

<p>The task:</p>

<ul>
<li>Create teams of 2</li>
<li>Pick a topic from the list below, or propose your own</li>
<li>Once you've selected a topic (or want to propose your own), reach out to me, and I'll give you some references and technical guidance where relevant</li>
<li>Most of these projects have an implementation component — you should feel free to use whatever language you want for that</li>
</ul>

<p>Deliverables:</p>

<ul>
<li>A 10-15 minutes presentation during final events period</li>
<li>Code for your implementation (when relevant) and instructions for how to run the code</li>
<li>A 5 pages write up describing the work and walking through the code</li>
</ul>

<hr>

<h2>Possible Topics</h2>

<h3>&epsilon;-NFAs to DFAs</h3>

<p>Write a program to transform &epsilon;-NFAs to DFAs, and use it to write a &quot;compiler&quot; for regular
expressions that takes a regular expression and creates a corresponding DFA that accepts the
language described by the regular expression.</p>

<h3>2-Tapes Turing Machines Simulation</h3>

<p>I defined two 2-tapes Turing machines in class, and mentioned the fact that you can transform any
2-tapes Turing machine into a single tape Turing machine that accepts and rejects the same strings,
by simulating the two tapes into a single tape. Write that transformation and use it to simulate
2-tapes Turing machines.</p>

<h3>Universal Turing Machines</h3>

<p>A <a href="https://en.wikipedia.org/wiki/Universal_Turing_machine">Universal Turing machine</a> is a Turing
machine that takes (the encoding of) a Turing machine as input as well as a string, and simulates
the input Turing machine running on that input string. Implement a Universal Turing machine, and use
it to simulate other Turing machines.</p>

<h3>Post Correspondence Problem</h3>

<p>We saw the Post Correspondence Problem in class as an example of a non-computable problem that is
not Turing-machine related. We can show it is non-computable by showing that if we could solve
the PCP, then we could solve the halting problem for Turing machines. The proof of this works by
showing that given a Turing machine M and an input w, we can construct a PCP instance (a set of
dominoes) with the property that the set of dominoes has a &quot;solution&quot; exactly when the Turing
machine M accepts input w. Implement the transformation from Turing machines to dominoes, and for a
Turing machine M and input w that Turing machine M accepts, construct the &quot;solution&quot; for the PCP
instance that shows that M accepts w.</p>

<h3>Pushdown Automata</h3>

<p>A <a href="https://en.wikipedia.org/wiki/Pushdown_automaton">Pushdown Automaton</a> is a type of finite state
machine with a <em>stack</em> that can be used to accept context-free languages. Implement a simulator for
pushdown automata, and write a transform that takes any context-free grammar and creates a
corresponding pushdown automaton that accepts that same language as generated by the context-free
grammar.</p>

<h3>Context-Free Grammars Parsing</h3>

<p>Context-free grammars <em>generate</em> strings. To determine if a string is in the language of a context-free grammar, we did it the hard way: we searchde through the space of all string generations to see if we can generate the string – if we can, we say yes, and if we can't or reach a search threshold, we say no. That's not great because the threshold can be high, and the search can be expensive. An alternative is <em>parsing</em>: taking the string, and trying to work backwards to see if we &quot;simplify&quot; the string back down to the starting symbol. There are many algorithms for parsing context-free grammars. Implement one from scratch.</p>

<h3>Unrestricted grammars</h3>

<p>Unrestricted grammars can simulate Turing machines. There is a construction that takes a Turing machine M and creates an unrestricted grammar G that generates exactly the strings that M accepts. Implement that construction, and write a function that given a Turing machine M and input w that you know M accepts, constructs the sequence of rewrites in the corresponding unrestricted grammar that generates string w.</p>

<h3>L-systems</h3>

<p>Read about <a href="https://en.wikipedia.org/wiki/L-system">L-systems</a>, which are a form of rewrite system
not dissimilar to context-free grammars, but used for different goals. Implement a renderer for
L-systems and use it to visualize interesting examples.</p>

<h3>The Game of Life</h3>

<p>The <a href="https://en.wikipedia.org/wiki/The_Game_of_Life">Game of Life</a> is a cellular automaton that
exhibits an impressive array of interesting and counter-intuitive (maybe?) behaviors. You can
simulate Turing machines with it. That's too hard though. Easier (but still tricky) is to implement
logic gates and build logic &quot;circuits&quot;. Do that. Yes, yes, I will send you references.</p>

    
  </body>
  
</html>

