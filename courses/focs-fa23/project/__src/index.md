
<script>
  document.title = 'Final Project - FOCS FA23'
</script>

# Final Project

## Due Date for deliverables: Sunday, Dec 17, 2023

Think of the final project as a more open-ended last homework with an associated short presentation.

The task: 

- Create teams of 2
- Pick a topic from the list below, or propose your own
- Once you've selected a topic (or want to propose your own), reach out to me, and I'll give you some references and technical guidance where relevant
- Most of these projects have an implementation component — you should feel free to use whatever language you want for that

Deliverables:

- A 10-15 minutes presentation during final events period
- Code for your implementation (when relevant) and instructions for how to run the code
- A 5 pages write up describing the work and walking through the code


***

## Possible Topics

### &epsilon;-NFAs to DFAs 

Write a program to transform &epsilon;-NFAs to DFAs, and use it to write a "compiler" for regular
expressions that takes a regular expression and creates a corresponding DFA that accepts the
language described by the regular expression.

### 2-Tapes Turing Machines Simulation

I defined two 2-tapes Turing machines in class, and mentioned the fact that you can transform any
2-tapes Turing machine into a single tape Turing machine that accepts and rejects the same strings,
by simulating the two tapes into a single tape. Write that transformation and use it to simulate
2-tapes Turing machines.

### Universal Turing Machines

A [Universal Turing machine](https://en.wikipedia.org/wiki/Universal_Turing_machine) is a Turing
machine that takes (the encoding of) a Turing machine as input as well as a string, and simulates
the input Turing machine running on that input string. Implement a Universal Turing machine, and use
it to simulate other Turing machines.


### Post Correspondence Problem

We saw the Post Correspondence Problem in class as an example of a non-computable problem that is
not Turing-machine related. We can show it is non-computable by showing that if we could solve
the PCP, then we could solve the halting problem for Turing machines. The proof of this works by
showing that given a Turing machine M and an input w, we can construct a PCP instance (a set of
dominoes) with the property that the set of dominoes has a "solution" exactly when the Turing
machine M accepts input w. Implement the transformation from Turing machines to dominoes, and for a
Turing machine M and input w that Turing machine M accepts, construct the "solution" for the PCP
instance that shows that M accepts w.

### Pushdown Automata

A [Pushdown Automaton](https://en.wikipedia.org/wiki/Pushdown_automaton) is a type of finite state
machine with a *stack* that can be used to accept context-free languages. Implement a simulator for
pushdown automata, and write a transform that takes any context-free grammar and creates a
corresponding pushdown automaton that accepts that same language as generated by the context-free
grammar.


### Context-Free Grammars Parsing

Context-free grammars *generate* strings. To determine if a string is in the language of a context-free grammar, we did it the hard way: we searchde through the space of all string generations to see if we can generate the string – if we can, we say yes, and if we can't or reach a search threshold, we say no. That's not great because the threshold can be high, and the search can be expensive. An alternative is *parsing*: taking the string, and trying to work backwards to see if we "simplify" the string back down to the starting symbol. There are many algorithms for parsing context-free grammars. Implement one from scratch.

### Unrestricted grammars

Unrestricted grammars can simulate Turing machines. There is a construction that takes a Turing machine M and creates an unrestricted grammar G that generates exactly the strings that M accepts. Implement that construction, and write a function that given a Turing machine M and input w that you know M accepts, constructs the sequence of rewrites in the corresponding unrestricted grammar that generates string w.


### L-systems

Read about [L-systems](https://en.wikipedia.org/wiki/L-system), which are a form of rewrite system
not dissimilar to context-free grammars, but used for different goals. Implement a renderer for
L-systems and use it to visualize interesting examples.


### The Game of Life

The [Game of Life](https://en.wikipedia.org/wiki/The_Game_of_Life) is a cellular automaton that
exhibits an impressive array of interesting and counter-intuitive (maybe?) behaviors. You can
simulate Turing machines with it. That's too hard though. Easier (but still tricky) is to implement
logic gates and build logic "circuits". Do that. Yes, yes, I will send you references.

