<script>
  document.title = 'Homework 4'
</script>

# Homework 4

## Due Date: Tuesday Oct 29, 2024 (23h59)

- This homework is to be done individually. You may discuss problems
with fellow students, but all submitted work must be entirely your
own, and should not be from any other course, present, past, or
future. If you use a solution from another source you must cite it
&mdash; this includes when that source is someone else helping
you.

- Please do not post your solutions on a public website or a public repository (including GitHub).

- All programming is to be done in Python 3.

- Code your answers by modifying the file [`homework4.py`](homework4.py) provided. Add your **name**, your **email address**, and any **remarks** that you
wish to make to the instructor to the block comment at the head of the file.

- Please do not change the "signature" (number and interpretation of arguments) of the
functions. Doing so will make it impossible to load your code into the testing infrastructure, and
make me unhappy.

- Feel free to define helper functions if you need them.


**Electronic Submission Instructions**

- Make your your file `homework4.py` loads without error in a fresh Python 3 shell.

- Submit `homework4.py` on [Canvas](https://canvas.olin.edu).

* * *

## Context-Free Grammars

We are going to describe context-free grammars in Python using the following structure:

    {
      "alphabet": ...,
      "nonterminals": ...,
      "rules": ...,
      "start": ...
    }
    
The dictionary fields hold the various components of the grammar: the input alphabet, the list of *nonterminal symbols* (the placeholder symbols that are used internally by the grammar and are not part of the input alphabet), a set of *grammar rules*, and a start symbol (which should be a nonterminal symbol)

The following grammar with starting symbol S, alphabet {`a`, `b`} and nonterminal {S} generates the
language {`a`<sup>n</sup>`b`<sup>n</sup> | n &ge; 0}:

   S &rarr; &epsilon;<br>
   S &rarr; `a` S `b` 

Here is how you represent that grammar with our structure:

    GR_ANBN = {
        "nonterminals": ["S"],
        "alphabet": ["a", "b"],
        "rules": [
            ("S", ""),
            ("S", "aSb")
        ],
        "start": "S"
    }

Note that a rule X &rarr; P is represented by a pair (X, P) where X is a nonterminal symbol and P is
a strings containing input symbols and nonterminal symbols.

Here is a grammar generating the language {`a`<sup>n</sup>`b`<sup>m</sup> | m &ge; n &ge; 0}:

    GR_ANMB = {
        "nonterminals": ["S", "T", "U"],
        "alphabet": ["a", "b"],
        "rules": [
            ("S", "TU"),
            ("T", ""),
            ("T", "aTb"),
            ("U", ""),
            ("U", "Ub")
        ],
        "start": "S"
    }

To check whether a string can be generated from a grammar, I provided you with a function:

    generate(grammar, input, n)

It takes a grammar, an input string, and a maximum depth parameter `n`. What's
that last parameter you ask?  Well, checking if a string can be generated by a grammar is done by
taking the start symbol, and repeatedly applying all possible rules until the string is
generated. That's expensive. Also, if the string cannot be generated, then this process never
terminates.  To control the process and prevent searching forever, rules are applied only up to
_maximum depth_ `n`: at most `n` rules can be applied in any sequence of rewrites. This means, in
particular, that if you know that a string requires K rewrites to be generated, then you need to
supply a value of at least K to function `generate`. The tricky bit is that the larger the
parameter `n`, the slower the generation process, because the tree of rewrites being searched gets
bigger as `n` increases. If your grammar gets too complicated, don't be surprised if it gets
difficult to generate strings you _know_ can be generated.

Function `generate()` will show you the sequence of rewrites when it finds one:

    >>> generate(GR_ANBN, "aaaabbbb", 20)
    Searching - depth 1
    Searching - depth 2
    Searching - depth 3
    Searching - depth 4
     A
    -> S
    -> aSb
    -> aaSbb
    -> aaaSbbb
    -> aaaabbbb
    True

Failures are less exciting:

    >>> generate(GR_ANBN, "aaaabbbbb", 20)
    Searching - depth 1
    Searching - depth 2
    Searching - depth 3
    Searching - depth 4
    Searching - depth 5
    Searching - depth 6
    Searching - depth 7
    Searching - depth 8
    Searching - depth 9
    Searching - depth 10
    Searching - depth 11
    Searching - depth 12
    Searching - depth 13
    Searching - depth 14
    Searching - depth 15
    Searching - depth 16
    Searching - depth 17
    Searching - depth 18
    Searching - depth 19
    False

Again, the depth parameter is important. If you put a depth that's not high enough, there MAY be a
derivation but the search will abort early:

    >>> generate(GR_ANBN, "aaaabbbbb", 4)
    Searching - depth 1
    Searching - depth 2
    Searching - depth 3
    False

Function `generate()` will check that a grammar is context free before running.

***

## Question 1: Context-Free Grammars

In this question, you will define context-free grammars generating specific languages. 

For submission purposes, please define those grammars as constants with a fixed name given below in
each question. There are already placeholders in `homework4.py` for those answers. Just replace each
placeholder with your definition.

### (A)

Construct a context-free grammar **`GR_A`** 
that generates the language of all strings of the form
`a`<sup>m</sup>`b`<sup>m+n</sup>`c`<sup>n</sup> for m, n &ge; 0, i.e.,
the set of all strings of `a`s followed by `b`s followed by `c`s,
where there are as many `b`s as `a`s and `c`s combined.

Sample strings in the generated language:

    ϵ                    [m=0, n=0]
    abbc                 [m=1, n=1]
    aabb                 [m=2, n=0]
    bbcc                 [m=0, n=2]
    abbbcc               [m=1, n=2]
    aabbbc               [m=2, n=1]
    aabbbbcc             [m=2, n=2]
    aabbbbbccc           [m=2, n=3]
    aaabbbbbcc           [m=3, n=2]

Sample strings _not_ in the generated language:

    cb
    ba
    ccba
    a
    b
    c
    ac
    abc
    abbcc
    abbbbcc
    aabbbcc
    aaabbcc


### (B)

Construct a context-free grammar **`GR_B`**
that generates the language of all strings of the form
`a`<sup>m</sup>`b`<sup>n</sup>`c`<sup>m+n</sup> for m, n &ge; 0, i.e., the set of all strings made up
of `a`s followed by `b`s 
followed by `c`s, where there are as many `c`s as `a`s and `b`s combined.

Sample strings in the generated language:

    ϵ                    [m=0, n=0]
    abcc                 [m=1, n=1]
    aacc                 [m=2, n=0]
    bbcc                 [m=0, n=2]
    abbccc               [m=1, n=2]
    aabccc               [m=2, n=1]
    aabbcccc             [m=2, n=2]
    aabbbccccc           [m=2, n=3]
    aaabbccccc           [m=3, n=2]

Sample strings _not_ in the generated language:

    cb
    ba
    cbba
    a
    b
    c
    ab
    abc
    aabbcc
    aabcc
    abbcc
    aabbccc
    aabcccc
    

### (C)

Construct a context-free grammar **`GR_C`**
that generates all strings over {`a`,`b`} that have the same number of `a`s and `b`s.

Sample strings in the generated language:

    ϵ
    ab
    ba
    aabb
    abab
    baab
    baba
    aaabbb
    ababab
    bbaaba
    abaabbabbaba

Sample strings _not_ in the generated language:

    a
    b
    abb
    aba
    babab
    bbaab
    aaabb
    abababa
    aaaaaab
    abbbbbb
    

### (D)

Construct a context-free grammar **`GR_D`** that generates the language
of all strings of the form `1`<sup>m</sup>`+1`<sup>n</sup>`=1`<sup>m+n</sup> for m, n &ge; 1
representing **unary** addition. For instance, `111+11=11111` represents 3 + 2 = 5, while `11+1=111`
represent 2 + 1 = 3.

Sample strings in the generated language:

    1+1=11
    11+1=111
    1+11=111
    11+11=1111
    11+1111=111111
    111+11111=11111111
    11111+111=11111111
    1111+1=11111

Sample strings _not_ in the generated language:

    +=
    +1=1
    1+=1
    1+1=1
    11+=1
    11+=111
    11+11=111
    11+11=11111
    1=1+1
    1+1+1=1
    1=1=1

**Hint**: Do not get distracted by the meaning of the symbols.


***

## Turing Machines

Here is a Python structure for deterministic Turing machines like we saw in class:

    {
        "states": ...,
        "alphabet": ...,
        "tape_alphabet": ...,
        "delta": ...,
        "start": ...,
        "accept": ...,
        "reject": ...
    }

The structure follows that of the Turing machines we've seen in class: a set of states, a set
of input symbols (the alphabet), a set of tape symbols (the tape alphabet), a transition function
delta, a start state, and an accept and reject state. Lists are used to represent sets. 

The transition relation is represented using list of tuples (_p_, _a_, _q_, _b_, _D_), stating that
in state _p_, when symbol _a_ is in the cell pointed to by tape head, the machine can
transition to state _q_, writing _b_ in the cell and then moving the tape head either one cell to
the left (_D_ = -1) or one cell to the right (_D_ = 1). When the tape head is on the leftmost cell
of the tape, moving to the left does not move the tape head. States can be represented by any value
that support equality checking. We do not allow null transitions. We use `_` as the symbol for blank
space, which should always be part of the tape alphabet.

As a simple example, here is the code representing a Turing machine accepting
the (context-free) language &lcub;a<sup>n</sup>b<sup>n</sup> | n &ge; 0&rcub;:

    TM_ANBN = {
        "states": [1, 2, 4, 6, 7, 777, 666],
        "alphabet": ['a','b'],
        "tape_alphabet": ['a','b','X','Y','_'],
        "start": 1,
        "accept": 777,
        "reject": 666,
        "delta": [
            (1, 'a', 2, 'X', 1),
            (1, '_', 777, '_', 1),
            (2, 'a', 2, 'a', 1),
            (2, 'Y', 2, 'Y', 1),
            (2, 'b', 4, 'Y', -1),
            (4, 'Y', 4, 'Y', -1),
            (4, 'a', 7, 'a', -1),
            (4, 'X', 6, 'X', 1),
            (6, 'Y', 6, 'Y', 1),
            (6, '_', 777, '_', 1),
            (7, 'a', 7, 'a', -1),
            (7, 'X', 1, 'X', 1)
        ]
    }

We follow the convention that when there is no transition from a given state and a given symbol,
then there IS in fact such a transition that goes to the reject state. 

When a Turing machine is given a string to accept or reject, it starts with that input string on the
tape starting at the leftmost cell. The portions of the tape not occupied by the input string is all
filled with blanks. The machine is initially in the start state. It transitions to another state via
an enabled transition (one that matches source state and source tape symbol). Following an enabled
transition moves the current state to the target state of the transition, writes a new tape symbol
on the tape, and moves the tape head left or right. It ever ends up in the accepting state, it
accepts the input string. If it ever ends up in the rejecting state, it rejects the input string.

In Question 2, you will complete a simulator for Turing machines that lets you simulate the
execution of a Turing machine on a given input string. Once you complete it, you will be able to
simulate, for instance, machine `TM_ANBN` on some input and determine if it accepts the string
(returns `True`) or rejects the string (returns `False`):

    >>> accept_tm(TM_ANBN, "aaabbb")
    1   [a] a  a  b  b  b 
    2    X [a] a  b  b  b 
    2    X  a [a] b  b  b 
    2    X  a  a [b] b  b 
    4    X  a [a] Y  b  b 
    7    X [a] a  Y  b  b 
    7   [X] a  a  Y  b  b 
    1    X [a] a  Y  b  b 
    2    X  X [a] Y  b  b 
    2    X  X  a [Y] b  b 
    2    X  X  a  Y [b] b 
    4    X  X  a [Y] Y  b 
    4    X  X [a] Y  Y  b 
    7    X [X] a  Y  Y  b 
    1    X  X [a] Y  Y  b 
    2    X  X  X [Y] Y  b 
    2    X  X  X  Y [Y] b 
    2    X  X  X  Y  Y [b]
    4    X  X  X  Y [Y] Y  _ 
    4    X  X  X [Y] Y  Y  _ 
    4    X  X [X] Y  Y  Y  _ 
    6    X  X  X [Y] Y  Y  _ 
    6    X  X  X  Y [Y] Y  _ 
    6    X  X  X  Y  Y [Y] _ 
    6    X  X  X  Y  Y  Y [_]
    777  X  X  X  Y  Y  Y  _ [_]
    True

***

## Question 2: Simulating Turing Machines

In this question, we are going to build the tools to accept or reject strings via Turing machines.

We are going to break down how to run a Turing machine into multiple functions. When running a
Turing machine we need to keep track of multiple things: the current state, the content of the tape,
and the current position of the tape head. We are going to collect all of the information into a
triple called a *configuration*, of the form (_q_, _tape_, _pos_) _q_ is a state of the Turing
machine, _tape_ is a string representing the content of the tape, and _pos_is a number &ge; 1
representing the position of the tape head. (The leftmost cell of the tape is at position 1)
Running a Turing machine basically means stepping from configuration to configuration, following
enabled transitions.

Note that the tape content in a configuration can always be extended to the right with blank symbols
`_` while denoting the same configuration. So in all of my sample outputs, you should ignore
trailing blank symbols on the tape, and feel free to handle trailing blanks differently. (My tester
will disregard trailing blanks.)


### (A) 

Code a function `step_tm(m, config)` taking a Turing machine `m` and a configuration of the form
`(state, tape, pos)`, and returning a list of all configurations that can be reached by following an
enabled transition from the given configuration: that is, it should return a list of all
configurations that you can obtain by following a transition from state `state` with symbol
`tape[pos - 1]`.

To capture the convention that non-existent transitions go to the reject state, make sure that if in
any given state and symbol there is no enabled transition, then `step_tm()` works _as though_ there
was an enabled transition that went to the reject state.

Sample output (order of results not relevant):

    >>> step_tm(TM_ANBN, (1, "ab", 1))
    [(2, 'Xb', 2)]
    
    >>> step_tm(TM_ANBN, (2, "Xb", 2))
    [(4, 'XY_', 1)]
    
    >>> step_tm(TM_ANBN, (4, "XY_", 1))
    [(6, 'XY_', 2)]
    
    >>> step_tm(TM_ANBN, (6, "XY_", 2))
    [(6, 'XY_', 3)]
    
    >>> step_tm(TM_ANBN, (6, "XY_", 3))
    [(777, 'XY__', 4)]
    
    >>> step_tm(TM_ANBN, (777, "XY__", 4))
    [(666, 'XY___', 5)]


### (B)

Code a function `start_tm(m, input)` taking a Turing machine `m` and an input string `input`
and returning the *starting configuration* for executing the machine.

Sample output:

    >>> start_tm(TM_ANBN, "")
    (1, '', 1)

    >>> start_tm(TM_ANBN, "aaabbb")
    (1, 'aaabbb', 1)

    >>> start_tm(TM_ANBN, "ababab")
    (1, 'ababab', 1)


### (C)

Code a function `is_done_tm(m, config)` that takes a Turing machine `m` and a configuration
`config` and returns `True` exactly when the configuration is a configuration that stops the machine.

Sample output:

    >>> is_done_tm(TM_ANBN, (1, "ab", 1))
    False

    >>> is_done_tm(TM_ANBN, (2, "Xb", 2))
    False

    >>> is_done_tm(TM_ANBN, (666, "XY___", 5))
    True

    >>> is_done_tm(TM_ANBN, (777, "XY__", 4))
    True


### (D)

Code a function `is_accept_tm(m, config)` that takes a Turing machine `m` and a configuration
`config` and returns `True` exactly when the configuration is an *accepting configuration*, that is
one that has an accepting state. 

Sample output:

    >>> is_accept_tm(TM_ANBN, (1, "ab", 1))
    False

    >>> is_accept_tm(TM_ANBN, (2, "Xb", 2))
    False

    >>> is_accept_tm(TM_ANBN, (666, "XY___", 5))
    False

    >>> is_accept_tm(TM_ANBN, (777, "XY__", 4))
    True


### (E)

Let's put the pieces we built above together to create a simulator for (deterministic) Turing
machines.

Code a function `accept_tm(m, input)` that takes a Turing machine`m`
and an input string `input` and returns True exactly when `m` accepts
input string `input`. Intuitively, this should work by starting with
the starting configuration, looping by applying `step_tm` to the
current configuration to obtain the next configuration, stopping when
we hit a halting configuration, and returning true when we have an
accepting configuration.

Make sure to check at every step that `step_tm()` returns exactly one
next configuration — if not, raise an exception pointing out that the
machine is nondeterministic. You also may want to call the function
`print_config()` I created for you to print the configuration within
the loop so that you see what the machine does when it runs.

Sample outputs:

    >>> accept_tm(TM_ANBN, "")
    1   [ ]
    777  _ [ ]
    True
    
    >>> accept_tm(TM_ANBN, "ab")
    1   [a] b 
    2    X [b]
    4   [X] Y  _ 
    6    X [Y] _ 
    6    X  Y [_]
    777  X  Y  _ [_]
    True
    
    >>> accept_tm(TM_ANBN, "aabb")
    1   [a] a  b  b 
    2    X [a] b  b 
    2    X  a [b] b 
    4    X [a] Y  b 
    7   [X] a  Y  b 
    1    X [a] Y  b 
    2    X  X [Y] b 
    2    X  X  Y [b]
    4    X  X [Y] Y  _ 
    4    X [X] Y  Y  _ 
    6    X  X [Y] Y  _ 
    6    X  X  Y [Y] _ 
    6    X  X  Y  Y [_]
    777  X  X  Y  Y  _ [_]
    True
    
    >>> accept_tm(TM_ANBN, "aaabbb")
    1   [a] a  a  b  b  b 
    2    X [a] a  b  b  b 
    2    X  a [a] b  b  b 
    2    X  a  a [b] b  b 
    4    X  a [a] Y  b  b 
    7    X [a] a  Y  b  b 
    7   [X] a  a  Y  b  b 
    1    X [a] a  Y  b  b 
    2    X  X [a] Y  b  b 
    2    X  X  a [Y] b  b 
    2    X  X  a  Y [b] b 
    4    X  X  a [Y] Y  b 
    4    X  X [a] Y  Y  b 
    7    X [X] a  Y  Y  b 
    1    X  X [a] Y  Y  b 
    2    X  X  X [Y] Y  b 
    2    X  X  X  Y [Y] b 
    2    X  X  X  Y  Y [b]
    4    X  X  X  Y [Y] Y  _ 
    4    X  X  X [Y] Y  Y  _ 
    4    X  X [X] Y  Y  Y  _ 
    6    X  X  X [Y] Y  Y  _ 
    6    X  X  X  Y [Y] Y  _ 
    6    X  X  X  Y  Y [Y] _ 
    6    X  X  X  Y  Y  Y [_]
    777  X  X  X  Y  Y  Y  _ [_]
    True
    
    >>> accept_tm(TM_ANBN, "b")
    1   [b]
    666  b [_]
    False
    
    >>> accept_tm(TM_ANBN, "aaabbba")
    1   [a] a  a  b  b  b  a 
    2    X [a] a  b  b  b  a 
    2    X  a [a] b  b  b  a 
    2    X  a  a [b] b  b  a 
    4    X  a [a] Y  b  b  a 
    7    X [a] a  Y  b  b  a 
    7   [X] a  a  Y  b  b  a 
    1    X [a] a  Y  b  b  a 
    2    X  X [a] Y  b  b  a 
    2    X  X  a [Y] b  b  a 
    2    X  X  a  Y [b] b  a 
    4    X  X  a [Y] Y  b  a 
    4    X  X [a] Y  Y  b  a 
    7    X [X] a  Y  Y  b  a 
    1    X  X [a] Y  Y  b  a 
    2    X  X  X [Y] Y  b  a 
    2    X  X  X  Y [Y] b  a 
    2    X  X  X  Y  Y [b] a 
    4    X  X  X  Y [Y] Y  a 
    4    X  X  X [Y] Y  Y  a 
    4    X  X [X] Y  Y  Y  a 
    6    X  X  X [Y] Y  Y  a 
    6    X  X  X  Y [Y] Y  a 
    6    X  X  X  Y  Y [Y] a 
    6    X  X  X  Y  Y  Y [a]
    666  X  X  X  Y  Y  Y  a [_]
    False
    
    >>> accept_tm(TM_ANBN, "aabbb")
    1   [a] a  b  b  b 
    2    X [a] b  b  b 
    2    X  a [b] b  b 
    4    X [a] Y  b  b 
    7   [X] a  Y  b  b 
    1    X [a] Y  b  b 
    2    X  X [Y] b  b 
    2    X  X  Y [b] b 
    4    X  X [Y] Y  b 
    4    X [X] Y  Y  b 
    6    X  X [Y] Y  b 
    6    X  X  Y [Y] b 
    6    X  X  Y  Y [b]
    666  X  X  Y  Y  b [_]
    False
    
    >>> accept_tm(TM_ANBN, "aaaabbb")
    1   [a] a  a  a  b  b  b 
    2    X [a] a  a  b  b  b 
    2    X  a [a] a  b  b  b 
    2    X  a  a [a] b  b  b 
    2    X  a  a  a [b] b  b 
    4    X  a  a [a] Y  b  b 
    7    X  a [a] a  Y  b  b 
    7    X [a] a  a  Y  b  b 
    7   [X] a  a  a  Y  b  b 
    1    X [a] a  a  Y  b  b 
    2    X  X [a] a  Y  b  b 
    2    X  X  a [a] Y  b  b 
    2    X  X  a  a [Y] b  b 
    2    X  X  a  a  Y [b] b 
    4    X  X  a  a [Y] Y  b 
    4    X  X  a [a] Y  Y  b 
    7    X  X [a] a  Y  Y  b 
    7    X [X] a  a  Y  Y  b 
    1    X  X [a] a  Y  Y  b 
    2    X  X  X [a] Y  Y  b 
    2    X  X  X  a [Y] Y  b 
    2    X  X  X  a  Y [Y] b 
    2    X  X  X  a  Y  Y [b]
    4    X  X  X  a  Y [Y] Y  _ 
    4    X  X  X  a [Y] Y  Y  _ 
    4    X  X  X [a] Y  Y  Y  _ 
    7    X  X [X] a  Y  Y  Y  _ 
    1    X  X  X [a] Y  Y  Y  _ 
    2    X  X  X  X [Y] Y  Y  _ 
    2    X  X  X  X  Y [Y] Y  _ 
    2    X  X  X  X  Y  Y [Y] _ 
    2    X  X  X  X  Y  Y  Y [_]
    666  X  X  X  X  Y  Y  Y  _ [_]
    False


***

## Question 3: Constructing Turing Machines

In this question, you will construct Turing machines. You can test your Turing machines with the
code you wrote in Question 2.

For submission purposes, please define those Turing machines as constants with a fixed name given
below in each question. There are already placeholders in `homework4.py` for those answers. Just
replace each placeholder with your definition.


### (A)

Construct a halting Turing machine **`TM_EQUAL`** that accepts the language consisting of all
strings over the alphabet `{a, b}` in which there are an equal number of `a`s and `b`s, but in any
order.

Sample accepted strings:

    ϵ
    ab
    ba
    aaabbb
    bbbaaa
    ababab
    abbbaa
    aaaabbbbab
    
    
Sample rejected strings:

    a
    b
    abababa
    bababab
    aaaabbbba


## (B)

Construct a halting Turing machine **`TM_AND`** that accepts the
language consisting of all strings over the alphabet `{0, 1, #}` of the
form _`#`u_`#`_v_`#`_w_ where _u_, _v_, and _w_ are nonempty strings over
`{0, 1}` all of the same length such that _w_ is the pointwise AND of
_u_ and _v:_ if the _i <sup>th</sup>_ bit of _u_ is _b1_ and the _i <sup>th</sup>_ bit of _v_
    is _b2_ then the _i <sup>th</sup>_ bit of _w_ is _b1 ∧ b2_, where _x ∧ y_ is 1
when both _x_ and _y_ are 1, and 0 otherwise.

Sample accepted strings:

    #0#0#0
    #0#1#0
    #1#0#0
    #1#1#1
    #01#11#01
    #01#00#00
    #00#11#00
    #101#010#000
    #111#010#010
    #1100#0011#0000
    #1110#0111#0110
    #0101#1010#0000
    #0101#0101#0101

Sample rejected strings:
    
    #0#0
    #0#0#1#1
    #00#11#11
    #001#001#000
    #001#001#011

### (C)

Construct a halting Turing machine **`TM_PLUS1`** that accepts the
language consisting of all strings over the alphabet `{0, 1, #}` of the
form _`#`u_`#`_v_ where _u_ and _v_ are nonempty
strings over `{0, 1}` all of the same length such that _u + 1 = v_ when
viewed as _binary numbers_.

(Brownie points if you can construct the Turing machine so that _u_
and _v_ need not be of the same length, but that's not required.)

Sample accepted strings:

    #0#1
    #00#01
    #000#001
    #010#011
    #011#100
    #100#101
    #101#110
    #110#111
    #101010#101011
    #101111#110000
    
Sample rejected strings:
    
    #0
    #0#1#1
    #0#11
    #01#0
    #1#1
    #0#0
    #010#101

**Hint**: how would you do 00101010101011 + 1 by hand, say? 

      00101010101011
    +              1
      --------------

Go from right to left, and distinguish situations where you have a carry from situations where
you don't using different states.


### (D)

Construct a halting Turing machine **`TM_PLUS`** that accepts the
language consisting of all strings over the alphabet `{0, 1, #}` of the
form _`#`u_`#`_v_`#`_w_ where _u_, _v_, and _w_ are nonempty strings over
`{0, 1}` all of the same length such that _u + v = w_ when viewed as _binary numbers_. 

(Brownie points if you can construct the Turing machine so that _u_, _v_, and _w_ need not be of the
same length, but that's not required.)

Sample accepted strings:

    #0#0#0
    #0#1#1
    #1#0#1
    #01#01#10
    #101#010#111
    #01110#00111#10101
    
Sample rejected strings:

    #0#0
    #0#0#0#0
    #0#0#1
    #00#11#10
    #001#001#011
    #001#001#100
