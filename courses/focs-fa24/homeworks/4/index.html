<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Riccardo Pucella</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="/static/main.css" type="text/css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    
  <style type="text/css">
     code { 
      white-space: pre;
     }

     body { 
       font-family: sans-serif;
       margin: 24px;
       line-height: 1.2;
       font-size: 16px;
     }

     hr, h2, h3, h4, h5, h6 {
         margin-top: 24px;
     }

     pre { 
         margin-left: 32px;
         color: blue;
     }
  </style>

  </head>


  <body>
  
    <script>
  document.title = 'Homework 4'
</script>

<h1>Homework 4</h1>

<h2>Due Date: Tuesday Oct 29, 2024 (23h59)</h2>

<ul>
<li><p>This homework is to be done individually. You may discuss problems
with fellow students, but all submitted work must be entirely your
own, and should not be from any other course, present, past, or
future. If you use a solution from another source you must cite it
&mdash; this includes when that source is someone else helping
you.</p></li>

<li><p>Please do not post your solutions on a public website or a public repository (including GitHub).</p></li>

<li><p>All programming is to be done in Python 3.</p></li>

<li><p>Code your answers by modifying the file <a href="homework4.py"><code>homework4.py</code></a> provided. Add your <strong>name</strong>, your <strong>email address</strong>, and any <strong>remarks</strong> that you
wish to make to the instructor to the block comment at the head of the file.</p></li>

<li><p>Please do not change the &quot;signature&quot; (number and interpretation of arguments) of the
functions. Doing so will make it impossible to load your code into the testing infrastructure, and
make me unhappy.</p></li>

<li><p>Feel free to define helper functions if you need them.</p></li>
</ul>

<p><strong>Electronic Submission Instructions</strong></p>

<ul>
<li><p>Make your your file <code>homework4.py</code> loads without error in a fresh Python 3 shell.</p></li>

<li><p>Submit <code>homework4.py</code> on <a href="https://canvas.olin.edu">Canvas</a>.</p></li>
</ul>

<hr>

<h2>Context-Free Grammars</h2>

<p>We are going to describe context-free grammars in Python using the following structure:</p>

<pre><code>{
  &quot;alphabet&quot;: ...,
  &quot;nonterminals&quot;: ...,
  &quot;rules&quot;: ...,
  &quot;start&quot;: ...
}
</code></pre>

<p>The dictionary fields hold the various components of the grammar: the input alphabet, the list of <em>nonterminal symbols</em> (the placeholder symbols that are used internally by the grammar and are not part of the input alphabet), a set of <em>grammar rules</em>, and a start symbol (which should be a nonterminal symbol)</p>

<p>The following grammar with starting symbol S, alphabet {<code>a</code>, <code>b</code>} and nonterminal {S} generates the
language {<code>a</code><sup>n</sup><code>b</code><sup>n</sup> | n &ge; 0}:</p>

<p>S &rarr; &epsilon;<br>
   S &rarr; <code>a</code> S <code>b</code></p>

<p>Here is how you represent that grammar with our structure:</p>

<pre><code>GR_ANBN = {
    &quot;nonterminals&quot;: [&quot;S&quot;],
    &quot;alphabet&quot;: [&quot;a&quot;, &quot;b&quot;],
    &quot;rules&quot;: [
        (&quot;S&quot;, &quot;&quot;),
        (&quot;S&quot;, &quot;aSb&quot;)
    ],
    &quot;start&quot;: &quot;S&quot;
}
</code></pre>

<p>Note that a rule X &rarr; P is represented by a pair (X, P) where X is a nonterminal symbol and P is
a strings containing input symbols and nonterminal symbols.</p>

<p>Here is a grammar generating the language {<code>a</code><sup>n</sup><code>b</code><sup>m</sup> | m &ge; n &ge; 0}:</p>

<pre><code>GR_ANMB = {
    &quot;nonterminals&quot;: [&quot;S&quot;, &quot;T&quot;, &quot;U&quot;],
    &quot;alphabet&quot;: [&quot;a&quot;, &quot;b&quot;],
    &quot;rules&quot;: [
        (&quot;S&quot;, &quot;TU&quot;),
        (&quot;T&quot;, &quot;&quot;),
        (&quot;T&quot;, &quot;aTb&quot;),
        (&quot;U&quot;, &quot;&quot;),
        (&quot;U&quot;, &quot;Ub&quot;)
    ],
    &quot;start&quot;: &quot;S&quot;
}
</code></pre>

<p>To check whether a string can be generated from a grammar, I provided you with a function:</p>

<pre><code>generate(grammar, input, n)
</code></pre>

<p>It takes a grammar, an input string, and a maximum depth parameter <code>n</code>. What's
that last parameter you ask?  Well, checking if a string can be generated by a grammar is done by
taking the start symbol, and repeatedly applying all possible rules until the string is
generated. That's expensive. Also, if the string cannot be generated, then this process never
terminates.  To control the process and prevent searching forever, rules are applied only up to
<em>maximum depth</em> <code>n</code>: at most <code>n</code> rules can be applied in any sequence of rewrites. This means, in
particular, that if you know that a string requires K rewrites to be generated, then you need to
supply a value of at least K to function <code>generate</code>. The tricky bit is that the larger the
parameter <code>n</code>, the slower the generation process, because the tree of rewrites being searched gets
bigger as <code>n</code> increases. If your grammar gets too complicated, don't be surprised if it gets
difficult to generate strings you <em>know</em> can be generated.</p>

<p>Function <code>generate()</code> will show you the sequence of rewrites when it finds one:</p>

<pre><code>&gt;&gt;&gt; generate(GR_ANBN, &quot;aaaabbbb&quot;, 20)
Searching - depth 1
Searching - depth 2
Searching - depth 3
Searching - depth 4
 A
-&gt; S
-&gt; aSb
-&gt; aaSbb
-&gt; aaaSbbb
-&gt; aaaabbbb
True
</code></pre>

<p>Failures are less exciting:</p>

<pre><code>&gt;&gt;&gt; generate(GR_ANBN, &quot;aaaabbbbb&quot;, 20)
Searching - depth 1
Searching - depth 2
Searching - depth 3
Searching - depth 4
Searching - depth 5
Searching - depth 6
Searching - depth 7
Searching - depth 8
Searching - depth 9
Searching - depth 10
Searching - depth 11
Searching - depth 12
Searching - depth 13
Searching - depth 14
Searching - depth 15
Searching - depth 16
Searching - depth 17
Searching - depth 18
Searching - depth 19
False
</code></pre>

<p>Again, the depth parameter is important. If you put a depth that's not high enough, there MAY be a
derivation but the search will abort early:</p>

<pre><code>&gt;&gt;&gt; generate(GR_ANBN, &quot;aaaabbbbb&quot;, 4)
Searching - depth 1
Searching - depth 2
Searching - depth 3
False
</code></pre>

<p>Function <code>generate()</code> will check that a grammar is context free before running.</p>

<hr>

<h2>Question 1: Context-Free Grammars</h2>

<p>In this question, you will define context-free grammars generating specific languages.</p>

<p>For submission purposes, please define those grammars as constants with a fixed name given below in
each question. There are already placeholders in <code>homework4.py</code> for those answers. Just replace each
placeholder with your definition.</p>

<h3>(A)</h3>

<p>Construct a context-free grammar <strong><code>GR_A</code></strong>
that generates the language of all strings of the form
<code>a</code><sup>m</sup><code>b</code><sup>m+n</sup><code>c</code><sup>n</sup> for m, n &ge; 0, i.e.,
the set of all strings of <code>a</code>s followed by <code>b</code>s followed by <code>c</code>s,
where there are as many <code>b</code>s as <code>a</code>s and <code>c</code>s combined.</p>

<p>Sample strings in the generated language:</p>

<pre><code>ϵ                    [m=0, n=0]
abbc                 [m=1, n=1]
aabb                 [m=2, n=0]
bbcc                 [m=0, n=2]
abbbcc               [m=1, n=2]
aabbbc               [m=2, n=1]
aabbbbcc             [m=2, n=2]
aabbbbbccc           [m=2, n=3]
aaabbbbbcc           [m=3, n=2]
</code></pre>

<p>Sample strings <em>not</em> in the generated language:</p>

<pre><code>cb
ba
ccba
a
b
c
ac
abc
abbcc
abbbbcc
aabbbcc
aaabbcc
</code></pre>

<h3>(B)</h3>

<p>Construct a context-free grammar <strong><code>GR_B</code></strong>
that generates the language of all strings of the form
<code>a</code><sup>m</sup><code>b</code><sup>n</sup><code>c</code><sup>m+n</sup> for m, n &ge; 0, i.e., the set of all strings made up
of <code>a</code>s followed by <code>b</code>s
followed by <code>c</code>s, where there are as many <code>c</code>s as <code>a</code>s and <code>b</code>s combined.</p>

<p>Sample strings in the generated language:</p>

<pre><code>ϵ                    [m=0, n=0]
abcc                 [m=1, n=1]
aacc                 [m=2, n=0]
bbcc                 [m=0, n=2]
abbccc               [m=1, n=2]
aabccc               [m=2, n=1]
aabbcccc             [m=2, n=2]
aabbbccccc           [m=2, n=3]
aaabbccccc           [m=3, n=2]
</code></pre>

<p>Sample strings <em>not</em> in the generated language:</p>

<pre><code>cb
ba
cbba
a
b
c
ab
abc
aabbcc
aabcc
abbcc
aabbccc
aabcccc
</code></pre>

<h3>(C)</h3>

<p>Construct a context-free grammar <strong><code>GR_C</code></strong>
that generates all strings over {<code>a</code>,<code>b</code>} that have the same number of <code>a</code>s and <code>b</code>s.</p>

<p>Sample strings in the generated language:</p>

<pre><code>ϵ
ab
ba
aabb
abab
baab
baba
aaabbb
ababab
bbaaba
abaabbabbaba
</code></pre>

<p>Sample strings <em>not</em> in the generated language:</p>

<pre><code>a
b
abb
aba
babab
bbaab
aaabb
abababa
aaaaaab
abbbbbb
</code></pre>

<h3>(D)</h3>

<p>Construct a context-free grammar <strong><code>GR_D</code></strong> that generates the language
of all strings of the form <code>1</code><sup>m</sup><code>+1</code><sup>n</sup><code>=1</code><sup>m+n</sup> for m, n &ge; 1
representing <strong>unary</strong> addition. For instance, <code>111+11=11111</code> represents 3 + 2 = 5, while <code>11+1=111</code>
represent 2 + 1 = 3.</p>

<p>Sample strings in the generated language:</p>

<pre><code>1+1=11
11+1=111
1+11=111
11+11=1111
11+1111=111111
111+11111=11111111
11111+111=11111111
1111+1=11111
</code></pre>

<p>Sample strings <em>not</em> in the generated language:</p>

<pre><code>+=
+1=1
1+=1
1+1=1
11+=1
11+=111
11+11=111
11+11=11111
1=1+1
1+1+1=1
1=1=1
</code></pre>

<p><strong>Hint</strong>: Do not get distracted by the meaning of the symbols.</p>

<hr>

<h2>Turing Machines</h2>

<p>Here is a Python structure for deterministic Turing machines like we saw in class:</p>

<pre><code>{
    &quot;states&quot;: ...,
    &quot;alphabet&quot;: ...,
    &quot;tape_alphabet&quot;: ...,
    &quot;delta&quot;: ...,
    &quot;start&quot;: ...,
    &quot;accept&quot;: ...,
    &quot;reject&quot;: ...
}
</code></pre>

<p>The structure follows that of the Turing machines we've seen in class: a set of states, a set
of input symbols (the alphabet), a set of tape symbols (the tape alphabet), a transition function
delta, a start state, and an accept and reject state. Lists are used to represent sets.</p>

<p>The transition relation is represented using list of tuples (<em>p</em>, <em>a</em>, <em>q</em>, <em>b</em>, <em>D</em>), stating that
in state <em>p</em>, when symbol <em>a</em> is in the cell pointed to by tape head, the machine can
transition to state <em>q</em>, writing <em>b</em> in the cell and then moving the tape head either one cell to
the left (<em>D</em> = -1) or one cell to the right (<em>D</em> = 1). When the tape head is on the leftmost cell
of the tape, moving to the left does not move the tape head. States can be represented by any value
that support equality checking. We do not allow null transitions. We use <code>_</code> as the symbol for blank
space, which should always be part of the tape alphabet.</p>

<p>As a simple example, here is the code representing a Turing machine accepting
the (context-free) language &lcub;a<sup>n</sup>b<sup>n</sup> | n &ge; 0&rcub;:</p>

<pre><code>TM_ANBN = {
    &quot;states&quot;: [1, 2, 4, 6, 7, 777, 666],
    &quot;alphabet&quot;: ['a','b'],
    &quot;tape_alphabet&quot;: ['a','b','X','Y','_'],
    &quot;start&quot;: 1,
    &quot;accept&quot;: 777,
    &quot;reject&quot;: 666,
    &quot;delta&quot;: [
        (1, 'a', 2, 'X', 1),
        (1, '_', 777, '_', 1),
        (2, 'a', 2, 'a', 1),
        (2, 'Y', 2, 'Y', 1),
        (2, 'b', 4, 'Y', -1),
        (4, 'Y', 4, 'Y', -1),
        (4, 'a', 7, 'a', -1),
        (4, 'X', 6, 'X', 1),
        (6, 'Y', 6, 'Y', 1),
        (6, '_', 777, '_', 1),
        (7, 'a', 7, 'a', -1),
        (7, 'X', 1, 'X', 1)
    ]
}
</code></pre>

<p>We follow the convention that when there is no transition from a given state and a given symbol,
then there IS in fact such a transition that goes to the reject state.</p>

<p>When a Turing machine is given a string to accept or reject, it starts with that input string on the
tape starting at the leftmost cell. The portions of the tape not occupied by the input string is all
filled with blanks. The machine is initially in the start state. It transitions to another state via
an enabled transition (one that matches source state and source tape symbol). Following an enabled
transition moves the current state to the target state of the transition, writes a new tape symbol
on the tape, and moves the tape head left or right. It ever ends up in the accepting state, it
accepts the input string. If it ever ends up in the rejecting state, it rejects the input string.</p>

<p>In Question 2, you will complete a simulator for Turing machines that lets you simulate the
execution of a Turing machine on a given input string. Once you complete it, you will be able to
simulate, for instance, machine <code>TM_ANBN</code> on some input and determine if it accepts the string
(returns <code>True</code>) or rejects the string (returns <code>False</code>):</p>

<pre><code>&gt;&gt;&gt; accept_tm(TM_ANBN, &quot;aaabbb&quot;)
1   [a] a  a  b  b  b 
2    X [a] a  b  b  b 
2    X  a [a] b  b  b 
2    X  a  a [b] b  b 
4    X  a [a] Y  b  b 
7    X [a] a  Y  b  b 
7   [X] a  a  Y  b  b 
1    X [a] a  Y  b  b 
2    X  X [a] Y  b  b 
2    X  X  a [Y] b  b 
2    X  X  a  Y [b] b 
4    X  X  a [Y] Y  b 
4    X  X [a] Y  Y  b 
7    X [X] a  Y  Y  b 
1    X  X [a] Y  Y  b 
2    X  X  X [Y] Y  b 
2    X  X  X  Y [Y] b 
2    X  X  X  Y  Y [b]
4    X  X  X  Y [Y] Y  _ 
4    X  X  X [Y] Y  Y  _ 
4    X  X [X] Y  Y  Y  _ 
6    X  X  X [Y] Y  Y  _ 
6    X  X  X  Y [Y] Y  _ 
6    X  X  X  Y  Y [Y] _ 
6    X  X  X  Y  Y  Y [_]
777  X  X  X  Y  Y  Y  _ [_]
True
</code></pre>

<hr>

<h2>Question 2: Simulating Turing Machines</h2>

<p>In this question, we are going to build the tools to accept or reject strings via Turing machines.</p>

<p>We are going to break down how to run a Turing machine into multiple functions. When running a
Turing machine we need to keep track of multiple things: the current state, the content of the tape,
and the current position of the tape head. We are going to collect all of the information into a
triple called a <em>configuration</em>, of the form (<em>q</em>, <em>tape</em>, <em>pos</em>) <em>q</em> is a state of the Turing
machine, <em>tape</em> is a string representing the content of the tape, and <em>pos</em>is a number &ge; 1
representing the position of the tape head. (The leftmost cell of the tape is at position 1)
Running a Turing machine basically means stepping from configuration to configuration, following
enabled transitions.</p>

<p>Note that the tape content in a configuration can always be extended to the right with blank symbols
<code>_</code> while denoting the same configuration. So in all of my sample outputs, you should ignore
trailing blank symbols on the tape, and feel free to handle trailing blanks differently. (My tester
will disregard trailing blanks.)</p>

<h3>(A)</h3>

<p>Code a function <code>step_tm(m, config)</code> taking a Turing machine <code>m</code> and a configuration of the form
<code>(state, tape, pos)</code>, and returning a list of all configurations that can be reached by following an
enabled transition from the given configuration: that is, it should return a list of all
configurations that you can obtain by following a transition from state <code>state</code> with symbol
<code>tape[pos - 1]</code>.</p>

<p>To capture the convention that non-existent transitions go to the reject state, make sure that if in
any given state and symbol there is no enabled transition, then <code>step_tm()</code> works <em>as though</em> there
was an enabled transition that went to the reject state.</p>

<p>Sample output (order of results not relevant):</p>

<pre><code>&gt;&gt;&gt; step_tm(TM_ANBN, (1, &quot;ab&quot;, 1))
[(2, 'Xb', 2)]

&gt;&gt;&gt; step_tm(TM_ANBN, (2, &quot;Xb&quot;, 2))
[(4, 'XY_', 1)]

&gt;&gt;&gt; step_tm(TM_ANBN, (4, &quot;XY_&quot;, 1))
[(6, 'XY_', 2)]

&gt;&gt;&gt; step_tm(TM_ANBN, (6, &quot;XY_&quot;, 2))
[(6, 'XY_', 3)]

&gt;&gt;&gt; step_tm(TM_ANBN, (6, &quot;XY_&quot;, 3))
[(777, 'XY__', 4)]

&gt;&gt;&gt; step_tm(TM_ANBN, (777, &quot;XY__&quot;, 4))
[(666, 'XY___', 5)]
</code></pre>

<h3>(B)</h3>

<p>Code a function <code>start_tm(m, input)</code> taking a Turing machine <code>m</code> and an input string <code>input</code>
and returning the <em>starting configuration</em> for executing the machine.</p>

<p>Sample output:</p>

<pre><code>&gt;&gt;&gt; start_tm(TM_ANBN, &quot;&quot;)
(1, '', 1)

&gt;&gt;&gt; start_tm(TM_ANBN, &quot;aaabbb&quot;)
(1, 'aaabbb', 1)

&gt;&gt;&gt; start_tm(TM_ANBN, &quot;ababab&quot;)
(1, 'ababab', 1)
</code></pre>

<h3>(C)</h3>

<p>Code a function <code>is_done_tm(m, config)</code> that takes a Turing machine <code>m</code> and a configuration
<code>config</code> and returns <code>True</code> exactly when the configuration is a configuration that stops the machine.</p>

<p>Sample output:</p>

<pre><code>&gt;&gt;&gt; is_done_tm(TM_ANBN, (1, &quot;ab&quot;, 1))
False

&gt;&gt;&gt; is_done_tm(TM_ANBN, (2, &quot;Xb&quot;, 2))
False

&gt;&gt;&gt; is_done_tm(TM_ANBN, (666, &quot;XY___&quot;, 5))
True

&gt;&gt;&gt; is_done_tm(TM_ANBN, (777, &quot;XY__&quot;, 4))
True
</code></pre>

<h3>(D)</h3>

<p>Code a function <code>is_accept_tm(m, config)</code> that takes a Turing machine <code>m</code> and a configuration
<code>config</code> and returns <code>True</code> exactly when the configuration is an <em>accepting configuration</em>, that is
one that has an accepting state.</p>

<p>Sample output:</p>

<pre><code>&gt;&gt;&gt; is_accept_tm(TM_ANBN, (1, &quot;ab&quot;, 1))
False

&gt;&gt;&gt; is_accept_tm(TM_ANBN, (2, &quot;Xb&quot;, 2))
False

&gt;&gt;&gt; is_accept_tm(TM_ANBN, (666, &quot;XY___&quot;, 5))
False

&gt;&gt;&gt; is_accept_tm(TM_ANBN, (777, &quot;XY__&quot;, 4))
True
</code></pre>

<h3>(E)</h3>

<p>Let's put the pieces we built above together to create a simulator for (deterministic) Turing
machines.</p>

<p>Code a function <code>accept_tm(m, input)</code> that takes a Turing machine<code>m</code>
and an input string <code>input</code> and returns True exactly when <code>m</code> accepts
input string <code>input</code>. Intuitively, this should work by starting with
the starting configuration, looping by applying <code>step_tm</code> to the
current configuration to obtain the next configuration, stopping when
we hit a halting configuration, and returning true when we have an
accepting configuration.</p>

<p>Make sure to check at every step that <code>step_tm()</code> returns exactly one
next configuration — if not, raise an exception pointing out that the
machine is nondeterministic. You also may want to call the function
<code>print_config()</code> I created for you to print the configuration within
the loop so that you see what the machine does when it runs.</p>

<p>Sample outputs:</p>

<pre><code>&gt;&gt;&gt; accept_tm(TM_ANBN, &quot;&quot;)
1   [ ]
777  _ [ ]
True

&gt;&gt;&gt; accept_tm(TM_ANBN, &quot;ab&quot;)
1   [a] b 
2    X [b]
4   [X] Y  _ 
6    X [Y] _ 
6    X  Y [_]
777  X  Y  _ [_]
True

&gt;&gt;&gt; accept_tm(TM_ANBN, &quot;aabb&quot;)
1   [a] a  b  b 
2    X [a] b  b 
2    X  a [b] b 
4    X [a] Y  b 
7   [X] a  Y  b 
1    X [a] Y  b 
2    X  X [Y] b 
2    X  X  Y [b]
4    X  X [Y] Y  _ 
4    X [X] Y  Y  _ 
6    X  X [Y] Y  _ 
6    X  X  Y [Y] _ 
6    X  X  Y  Y [_]
777  X  X  Y  Y  _ [_]
True

&gt;&gt;&gt; accept_tm(TM_ANBN, &quot;aaabbb&quot;)
1   [a] a  a  b  b  b 
2    X [a] a  b  b  b 
2    X  a [a] b  b  b 
2    X  a  a [b] b  b 
4    X  a [a] Y  b  b 
7    X [a] a  Y  b  b 
7   [X] a  a  Y  b  b 
1    X [a] a  Y  b  b 
2    X  X [a] Y  b  b 
2    X  X  a [Y] b  b 
2    X  X  a  Y [b] b 
4    X  X  a [Y] Y  b 
4    X  X [a] Y  Y  b 
7    X [X] a  Y  Y  b 
1    X  X [a] Y  Y  b 
2    X  X  X [Y] Y  b 
2    X  X  X  Y [Y] b 
2    X  X  X  Y  Y [b]
4    X  X  X  Y [Y] Y  _ 
4    X  X  X [Y] Y  Y  _ 
4    X  X [X] Y  Y  Y  _ 
6    X  X  X [Y] Y  Y  _ 
6    X  X  X  Y [Y] Y  _ 
6    X  X  X  Y  Y [Y] _ 
6    X  X  X  Y  Y  Y [_]
777  X  X  X  Y  Y  Y  _ [_]
True

&gt;&gt;&gt; accept_tm(TM_ANBN, &quot;b&quot;)
1   [b]
666  b [_]
False

&gt;&gt;&gt; accept_tm(TM_ANBN, &quot;aaabbba&quot;)
1   [a] a  a  b  b  b  a 
2    X [a] a  b  b  b  a 
2    X  a [a] b  b  b  a 
2    X  a  a [b] b  b  a 
4    X  a [a] Y  b  b  a 
7    X [a] a  Y  b  b  a 
7   [X] a  a  Y  b  b  a 
1    X [a] a  Y  b  b  a 
2    X  X [a] Y  b  b  a 
2    X  X  a [Y] b  b  a 
2    X  X  a  Y [b] b  a 
4    X  X  a [Y] Y  b  a 
4    X  X [a] Y  Y  b  a 
7    X [X] a  Y  Y  b  a 
1    X  X [a] Y  Y  b  a 
2    X  X  X [Y] Y  b  a 
2    X  X  X  Y [Y] b  a 
2    X  X  X  Y  Y [b] a 
4    X  X  X  Y [Y] Y  a 
4    X  X  X [Y] Y  Y  a 
4    X  X [X] Y  Y  Y  a 
6    X  X  X [Y] Y  Y  a 
6    X  X  X  Y [Y] Y  a 
6    X  X  X  Y  Y [Y] a 
6    X  X  X  Y  Y  Y [a]
666  X  X  X  Y  Y  Y  a [_]
False

&gt;&gt;&gt; accept_tm(TM_ANBN, &quot;aabbb&quot;)
1   [a] a  b  b  b 
2    X [a] b  b  b 
2    X  a [b] b  b 
4    X [a] Y  b  b 
7   [X] a  Y  b  b 
1    X [a] Y  b  b 
2    X  X [Y] b  b 
2    X  X  Y [b] b 
4    X  X [Y] Y  b 
4    X [X] Y  Y  b 
6    X  X [Y] Y  b 
6    X  X  Y [Y] b 
6    X  X  Y  Y [b]
666  X  X  Y  Y  b [_]
False

&gt;&gt;&gt; accept_tm(TM_ANBN, &quot;aaaabbb&quot;)
1   [a] a  a  a  b  b  b 
2    X [a] a  a  b  b  b 
2    X  a [a] a  b  b  b 
2    X  a  a [a] b  b  b 
2    X  a  a  a [b] b  b 
4    X  a  a [a] Y  b  b 
7    X  a [a] a  Y  b  b 
7    X [a] a  a  Y  b  b 
7   [X] a  a  a  Y  b  b 
1    X [a] a  a  Y  b  b 
2    X  X [a] a  Y  b  b 
2    X  X  a [a] Y  b  b 
2    X  X  a  a [Y] b  b 
2    X  X  a  a  Y [b] b 
4    X  X  a  a [Y] Y  b 
4    X  X  a [a] Y  Y  b 
7    X  X [a] a  Y  Y  b 
7    X [X] a  a  Y  Y  b 
1    X  X [a] a  Y  Y  b 
2    X  X  X [a] Y  Y  b 
2    X  X  X  a [Y] Y  b 
2    X  X  X  a  Y [Y] b 
2    X  X  X  a  Y  Y [b]
4    X  X  X  a  Y [Y] Y  _ 
4    X  X  X  a [Y] Y  Y  _ 
4    X  X  X [a] Y  Y  Y  _ 
7    X  X [X] a  Y  Y  Y  _ 
1    X  X  X [a] Y  Y  Y  _ 
2    X  X  X  X [Y] Y  Y  _ 
2    X  X  X  X  Y [Y] Y  _ 
2    X  X  X  X  Y  Y [Y] _ 
2    X  X  X  X  Y  Y  Y [_]
666  X  X  X  X  Y  Y  Y  _ [_]
False
</code></pre>

<hr>

<h2>Question 3: Constructing Turing Machines</h2>

<p>In this question, you will construct Turing machines. You can test your Turing machines with the
code you wrote in Question 2.</p>

<p>For submission purposes, please define those Turing machines as constants with a fixed name given
below in each question. There are already placeholders in <code>homework4.py</code> for those answers. Just
replace each placeholder with your definition.</p>

<h3>(A)</h3>

<p>Construct a halting Turing machine <strong><code>TM_EQUAL</code></strong> that accepts the language consisting of all
strings over the alphabet <code>{a, b}</code> in which there are an equal number of <code>a</code>s and <code>b</code>s, but in any
order.</p>

<p>Sample accepted strings:</p>

<pre><code>ϵ
ab
ba
aaabbb
bbbaaa
ababab
abbbaa
aaaabbbbab
</code></pre>

<p>Sample rejected strings:</p>

<pre><code>a
b
abababa
bababab
aaaabbbba
</code></pre>

<h2>(B)</h2>

<p>Construct a halting Turing machine <strong><code>TM_AND</code></strong> that accepts the
language consisting of all strings over the alphabet <code>{0, 1, #}</code> of the
form <em><code>#</code>u</em><code>#</code><em>v</em><code>#</code><em>w</em> where <em>u</em>, <em>v</em>, and <em>w</em> are nonempty strings over
<code>{0, 1}</code> all of the same length such that <em>w</em> is the pointwise AND of
<em>u</em> and <em>v:</em> if the <em>i <sup>th</sup></em> bit of <em>u</em> is <em>b1</em> and the <em>i <sup>th</sup></em> bit of <em>v</em>
    is <em>b2</em> then the <em>i <sup>th</sup></em> bit of <em>w</em> is <em>b1 ∧ b2</em>, where <em>x ∧ y</em> is 1
when both <em>x</em> and <em>y</em> are 1, and 0 otherwise.</p>

<p>Sample accepted strings:</p>

<pre><code>#0#0#0
#0#1#0
#1#0#0
#1#1#1
#101#010#000
#111#010#010
#1100#0011#0000
#1110#0111#0110
#0101#1010#0000
#0101#0101#0101
</code></pre>

<p>Sample rejected strings:</p>

<pre><code>#0#0
#0#0#1#1
#00#11#00
#001#001#000
#001#001#011
</code></pre>

<h3>(C)</h3>

<p>Construct a halting Turing machine <strong><code>TM_PLUS1</code></strong> that accepts the
language consisting of all strings over the alphabet <code>{0, 1, #}</code> of the
form <em><code>#</code>u</em><code>#</code><em>v</em> where <em>u</em> and <em>v</em> are nonempty
strings over <code>{0, 1}</code> all of the same length such that <em>u + 1 = v</em> when
viewed as <em>binary numbers</em>.</p>

<p>(Brownie points if you can construct the Turing machine so that <em>u</em>
and <em>v</em> need not be of the same length, but that's not required.)</p>

<p>Sample accepted strings:</p>

<pre><code>#0#1
#00#01
#000#001
#010#011
#011#100
#100#101
#101#110
#110#111
#101010#101011
#101111#110000
</code></pre>

<p>Sample rejected strings:</p>

<pre><code>#0
#0#1#1
#0#11
#01#0
#1#1
#0#0
#010#101
</code></pre>

<p><strong>Hint</strong>: how would you do 00101010101011 + 1 by hand, say?</p>

<pre><code>  00101010101011
+              1
  --------------
</code></pre>

<p>Go from right to left, and distinguish situations where you have a carry from situations where
you don't using different states.</p>

<h3>(D)</h3>

<p>Construct a halting Turing machine <strong><code>TM_PLUS</code></strong> that accepts the
language consisting of all strings over the alphabet <code>{0, 1, #}</code> of the
form <em><code>#</code>u</em><code>#</code><em>v</em><code>#</code><em>w</em> where <em>u</em>, <em>v</em>, and <em>w</em> are nonempty strings over
<code>{0, 1}</code> all of the same length such that <em>u + v = w</em> when viewed as <em>binary numbers</em>.</p>

<p>(Brownie points if you can construct the Turing machine so that <em>u</em>, <em>v</em>, and <em>w</em> need not be of the
same length, but that's not required.)</p>

<p>Sample accepted strings:</p>

<pre><code>#0#0#0
#0#1#1
#1#0#1
#01#01#10
#101#010#111
#01110#00111#10101
</code></pre>

<p>Sample rejected strings:</p>

<pre><code>#0#0
#0#0#0#0
#0#0#1
#00#11#10
#001#001#011
#001#001#100
</code></pre>

    
  </body>
  
</html>

