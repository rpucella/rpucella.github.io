<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Foundations of Computer Science (Fall 2018)</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>
      
        code,tt,pre {
          font-size: 110%;
        }

	ul.annoucements p { 
    	  padding-left: 5em;
    	  text-indent: -5em; 
        }

	ul.annoucements p span {
   	  padding-right: 1em
	}
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	table.office-hours td {
	  padding-left: 30px;
	}

    </style>

    <script>
      window.addEventListener("load",run);

      function run () {
        // CREATE SCROLLING BEHAVIOR FOR NAVIGATION BAR
        // actually, for anything with "scrollto" class

        // offset is given by the 'top' div (adjusted for padding)
        var off = document.getElementById("top").clientHeight;
        console.log(off);
        //var elts = document.querySelectorAll("div.navbar a");
        var elts = document.querySelectorAll("a.scrollto");
        for (var i=0; i<elts.length; i++) {
          var href=elts[i].getAttribute("href").slice(1);
          elts[i].setAttribute("onclick","return false;");
          elts[i].setAttribute("onmousedown","autoScroll.autoScrollTo(\""+href+"\",-"+(off)+");");
        }

      }


      </script>
  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a class="scrollto" href="#top"><b>Foundations of Computer Science FA18</b></a></li> 
	<li><a class="scrollto" href="#announcements">Announcements</a></li>
	<li><a class="scrollto" href="#info">Course Info</a></li>
	<li><a class="scrollto" href="#lectures">Lectures</a></li>
	<li><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 5em;"></div>
    
    <h1 class="clear">Foundations of Computer Science (Fall 2018)</h1>
    
    <p class="subtitle">ENGR 3520 / Tue 15:20-17:50 / AC 326</p>
    
    <p>This course explores the notion of computation. We're going to
      develop formal tools for defining what we mean by computation
      through various models, including automata and the lambda
      calculus. We will examine how some of these alternative models
      of computations correspond to different programming paradigms.
</p>


    
    <hr class="section">
    <div class="section" id="announcements">
      <h3>Announcements</h3>

      <ul class="simple annoucements">

	<!--	<li><p><a href="announcements.html">Older announcements...</a></p></li> -->

	<li><p><span>Dec 3:</span> Our final exam will be on <b>Wednesday December 12</b>, 4-7:00pm, in AC326. As for the midterm, this is closed books, but you have the right to a cheat sheet (double-sided 8.5x11"). Here are the <a href="final-topics.txt">topics covered</a> by the final.</p>
	  
        <li><p><span>Nov 23:</span> Happy post-Thanksgiving everybody! <a href="#">Homework 9</a> is out. Due next <del>Friday</del> Sunday before midnight.</p>
	</li>
	
        <li><p><span>Nov 9:</span> <a href="#">Homework 8</a> is out. Due next Friday before midnight.</p>
	</li>
	
	<li><p><span>Nov 7:</span> Class notes and remarks on the lambda calculus posted below.</p>
	    </li>
	
        <li><p><span>Nov 1:</span> <a href="#">Homework 7</a> is out. Due next Thursday before midnight.</p>
	    </li>
        
        <li><p><span>Oct 26:</span> <a href="#">Homework 6</a> is out. Due next Thursday before midnight.</p>
	    </li>
        
        <li><p><span>Oct 25:</span> The <a href="notes-functional.html">reading</a> required for the homework. It's about functional programming and higher-order functions. It is meant to be read actively: please try the various exercises, and copy and paste the code in an OCaml session.</p>
	</li>

	<li><p><span>Oct 16:</span> The <a href="midterm-topics.txt">topics covered</a> by the midterm.</p>

        <li><p><span>Oct 11:</span> <a href="#">Homework 5</a> is out. Due next Thursday before midnight.</p>
	</li>

        <li><p><span>Oct 5:</span> Class notes and remarks on Turing machines posted below.</p>
	</li>
	
        <li><p><span>Sep 28:</span> <a href="#">Homework 4</a> is out. Due next Thursday before midnight.</p>
	</li>

        <li><p><span>Sep 26</span> Class notes and remarks on finite automata posted below.</p>
	</li>
	
        <li><p><span>Sep 21:</span> <a href="#">Homework 3</a> is out. Due next Thursday before midnight.</p>
	</li>

	
        <li><p><span>Sep 20:</span> Class notes and remarks on formal languages and regular expressions posted below.</p>
	</li>


        <li><p><span>Sep 14:</span> <a href="#">Homework 2</a> is out. Due next Thursday before midnight.</p>
	</li>

        <li><p><span>Sep 6:</span> <a href="#">Homework 1</a> is out. Due next Wednesday before midnight.</p>
	</li>

         <li><p><span>Sep 4:</span>
	    Welcome to FoCS!</p>
	</li>
	
      </ul>
      
    </div>


    
    <hr class="section">
    <div class="section" id="info">
      <h3>Course Information</h3>

      <p><b>Prerequisites:</b> Discrete Mathematics is no longer a formal prerequisite for FoCS. Prior experience programming will be helpful, since I will not teach programming, as will facility with basic set-theoretic concepts.</p>

      <p><b>Instructor:</b> <a href="http://www.rpucella.net">Riccardo Pucella</a> (&#x72;&#x69;&#x63;&#x63;&#x61;&#x72;&#x64;&#x6F;&#x2E;&#x70;&#x75;&#x63;&#x65;&#x6C;&#x6C;&#x61;&#x40;&#x6F;&#x6C;&#x69;&#x6E;&#x2E;&#x65;&#x64;&#x75;)</p>

      <p><b>Office hours:</b> Tue 14:00-15:00 / MH 353. (Also available online &mdash; send email to coordinate.)</p>

      <p><b>Textbooks:</b> There is no required textbook for the course. We will be working off notes and online references.</p>

      <p>
	There are several excellent books on Theory of Computation
      (the first part of the course), but they are a bit expensive considering that we will 
	be covering only a small part of their content. If you need extra assistance, though, any of these books would be useful:
      <ul>
	<li>Sisper, <i><a href="https://www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/1133187811">Introduction to the Theory of Computation</a></i></li>
	<li>Hopcroft, Motwani, Ullman, <i><a href="https://www.amazon.com/Introduction-Automata-Theory-Languages-Computation/dp/0321455363">Automata Theory, Languages, and Computation</a></i></li>
      </ul>
      The library has those two books on reserve. Feel free to go and consult them.
      </p>

      <p>
      An inexpensive and reasonable book is the following, although it uses Ruby instead of OCaml:
      <ul>
	<li>Stuart, <i><a href="http://computationbook.com">Understanding Computation</a></i></li>
      </ul>
      It very much follows the spirit of this iteration of FoCS.
      </p>
    
      <p><b>Programming:</b> All programming in this course will be done
      using the programming
      language <a href="https://ocaml.org/">OCaml</a>. The OCaml
      interpreter can be downloaded from the web site, and
	supports installations on most common systems. Here are a couple of reasonable books on OCaml that you might
      want to get your hands on if you prefer learning your
      programming language from a book instead of the web:</p>
      
      <ul>
	<li>Hickey, <i><a href="http://courses.cms.caltech.edu/cs134/cs134b/book.pdf">Introduction
	      to Objective Caml</a></i> (PDF)</li>
	<li>Downey, Monje, <i><a href="http://greenteapress.com/thinkocaml/">Think
	  OCaml</a></i></li>
	<li>Minsky, Madhavapeddy, Hickey, <i><a href="https://realworldocaml.org/">Real World
	  OCaml</a></i></li>
      </ul>

      <p>Some online resources:</p>
      <ul>

	<li><a href="https://ocaml.org/learn/tutorials/basics.html">OCaml: The Basics</a> is a very small tutorial giving you the basics of interacting with OCaml.</li>

	<li>Some information on
	  the <a href="http://caml.inria.fr/pub/docs/manual-ocaml/toplevel.html#sec256">commands
	    you can use in the OCaml shell</a>, which can be
	  useful</li>

	<li>The <a href="http://caml.inria.fr/pub/docs/manual-ocaml/index.html">official
	    OCaml manual</a></li>

	<li>There are no official IDEs for OCaml, but many
	  people swear
	  by <a href="https://github.com/diml/utop"><i>utop</i></a>,
	  which is an OCaml shell replacement. There's also
	  <a href="http://camelia.sourceforge.net/"><i>Camelia</i></a>,
	  but I've never used it. There is
	  an <a href="http://www.algo-prog.info/ocaide/">Eclipse
	    plug-in</a> for OCaml.
	</li>
      </ul>
      

      <p><b>Grading:</b> The final grade is based on weekly homework
      (70%) and two exams (15% each).  All work will be done
      individually. Late homeworks will be penalized (10% per 24
      hours) and no homework will be accepted after its solution has
      been discussed in class.

      <b>Please do not post your code on a public available repository
	like GitHub. I hate to do this kind of policing, but we've had
	some issues in the past, and I'd like to avoid a repeat if
	possible.</b>

      <p><b>Ninjas:</b> We have a ninja for the class: Taylor Sheneman
      (<tt>taylor</tt> at the
      usual <tt>students</tt>.<tt>olin</tt>.<tt>edu</tt>). His office
      hours will be posted here when they're settled.</p>
      </p>

      <p>I will expect all of us to follow the <a href="http://www.olin.edu/academic-life/student-affairs-resources/student-life/honor-code/">Olin Honor Code</a>.</p>

     </div>


    <hr class="section">
    <div class="section" id="lectures">

      <h3>Lectures and Readings</h3>

      <p>Schedule and topics subject to last-minute changes.</p>
      
      <ul class="lectures">
	
	<li><p><span class="hdr">Sep 4:</span><b>Introduction / OCaml</b></p>
	  <div class="lect">

        <p>Some mathematicians I mentioned: <a href="https://en.wikipedia.org/wiki/Euclid">Euclid</a>,  <a href="https://en.wikipedia.org/wiki/%C3%89variste_Galois">
            Galois</a>, <a href="https://en.wikipedia.org/wiki/David_Hilbert">Hilbert</a>, <a href="https://en.wikipedia.org/wiki/Stephen_Cole_Kleene">Kleene</a>, <a href="https://en.wikipedia.org/wiki/Alonzo_Church">Church</a>, <a href="https://en.wikipedia.org/wiki/Alan_Turing">Turing</a>.</p>

        <p>Some interesting history about the <a href="http://www-history.mcs.st-and.ac.uk/history/HistTopics/Quadratic_etc_equations.html">quadratic, cubic, and quartic equations</a>. They are intrinsically bound to the discovery of complex numbers.</p>

	    <p><a href="https://en.wikipedia.org/wiki/Hilbert's_problems">Hilbert's
		problems</a>, ten of which were presented at the ICM
		in Paris in
		1900. His <a href="https://en.wikipedia.org/wiki/Hilbert's_tenth_problem">tenth
		problem</a> spoke directly to the notion of
		computation.</p>
	    
       <p>An <a href="notes-ocaml.html">annotated variant</a> of
		  the sample interaction with OCaml I gave in class. This is not meant to replace the
          links I provided above. This is just to give a flavor of the language.</p> 
	    
	  </div>
	</li>	  

	<li><p><span class="hdr">Sep 11:</span><b>Abacuses</b></p>
	  <div class="lect">
	    <p>I based the bulk of the lecture on the first chapter of Lambek's <a href="http://www.math.mcgill.ca/~barr/papers/pga.pdf"><i>Programs, Grammars, Arguments</i></a>. </p>
	    <p><a href="notes/non-computable-abacus.pdf">Notes on the non-computability of some functions in the abacus model</a>.
	  </div>
	</li>	  

	<li><p><b>MACHINE MODELS OF COMPUTATION</b></p></li>

	<li><p><span class="hdr">Sep 18:</span><b>Formal languages</b></p>
	  <div class="lect">
	    <p><a href="notes/languages.pdf">Notes on formal languages</a>.</p>
	    <p>Regular expressions are often used to search for patterns in text. <a href="http://www.cs.columbia.edu/~tal/3261/fall07/handout/egrep_mini-tutorial.htm">Here is an example of how they are used in egrep</a>.</p>
	  </div>
	</li>
	

	<li><p><span class="hdr">Sep 25:</span><b>Finite automata</b></p>
	  <div class="lect">
	    <p><a href="notes/automata.pdf">Notes from the lecture.</a></p>
	    <p>The notes include some things I did not get to (turning
	    a finite automaton into a deterministic one) and some
	    supplementary material at the end, fleshing out things
	    that I think are pretty interesting: (1) I show how the
	    language accepted by a finite automaton must be regular;
	    (2) I point out how you can use finite automata to show
	    that the complement of a regular language is regular; (3)
	    I show how you can use finite automata to argue that some
	    languages are not regular. I will talk about some of this
	    next time. </p>
	    <p>I pointed out in class one reason we study
nondeterministic forms of finite automata is that they can be easier
to describe than deterministic finite automata. More specifically,
there exists languages that can be accepted by nondeterministic finite
automata with N states whose smallest deterministic finite automata
that accept those same languages have at least 2<sup>N</sup>
states. One example is the language over {<tt>a</tt>,<tt>b</tt>}
consisting of all strings whose Nth from last symbol
is <tt>a</tt>. <a href="https://commons.wikimedia.org/wiki/File:NFA_with_exponential_blown-up_DFA.gif">Here
is an illustration</a> of the subset construction for that language,
over alphabet {0,1}, and N=4.</p>
	  </div>
	</li>	  


	<li><p><span class="hdr">Oct 2:</span><b>Turing machines I</b></p>
	  <div class="lect">
	    <p><a href="notes/turing.pdf">Notes from the lecture.</a> These cover this lecture and the next. (I just noticed that the Turing machine diagrams I give in the notes mess up the transitions on a blank symbol, printing <tt>/</tt> instead of <tt>_/_</tt> &mdash; I'll fix that in an upcoming revision. Sorry about that.)</p>
	    
	    <p><a href="https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf"><i>On Computable Numbers, with an Application to the Entscheidungsproblem</i></a>, the original paper by Turing that describes his machines. (Though it's not the most accessible description.)</p>
	    
	    <p>There are machines that are more expressive than finite
	    automata (i.e. accept non-regular languages) but less
	    expressive than Turing machines. One example
	    is <a href="https://en.wikipedia.org/wiki/Pushdown_automaton">pushdown
	    automata</a>, which are finite automata equipped with a
	    stack. They accept a class of languages that is larger
	    (and includes) regular languages, but smaller than what is
	      accepted by Turing machines.</p>

	    <p>I talked about the possibility of adding a counter to finite automata. The resulting model is called a <a href="https://en.wikipedia.org/wiki/Counter_automaton">counter automaton</a>. When equipped with a single counter, it can accept languages such as {<tt>a</tt><sup>n</sup><tt>b</tt><sup>n</sup> | n &ge; 0}, but cannot accept all languages that Turing machines accept. When equipped with two counters, the resulting machines are equivalent to Turing machines.</p>
	    
	</li>

	
	<li><p><span class="hdr">Oct 9:</span><b>Turing Machines II</b></p>
	  <div class="lect">

	    <p>The <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">Church-Turing thesis</a>.</p>

	  </div>	    
	</li>	  

	<li><p><span class="hdr">Oct 16</span><b>Universal Turing Machines and Undecidability</b></p>
	  <div class="lect">
	    <p><a href="notes/undecidable.pdf">Notes from the lecture</a>, including the full counting argument showing that there must exist at least one undecidable language.</p>

	    <p><a href="http://io9.gizmodo.com/5873581/the-odd-genius-who-showed-that-one-infinity-was-greater-than-another">Georg Cantor</a> the odd genius.</p>
	    
	    <p>A quick introduction
	      to <a href="https://en.wikipedia.org/wiki/Universal_Turing_machine">Universal
		Turing machines</a> from Wikipedia. Moore gives a
	      <a href="refs/moore.pdf">multi-tape implementation of a Universal Turing
		machine in 15 states</a>. </p>

	    <p>The <a href="https://en.wikipedia.org/wiki/Post_correspondence_problem">Post Correspondence Problem</a>.</p>
	  </div>

	</li>

	
	<li><p><span class="hdr">Oct 23</span><b>Midterm, and Functional Programming I: Higher-order functions</b></p>
		<div class="lect">
		  <p>The <a href="./notes-functional.html">reading I
		  mentioned</a> in class. It is reasonably
		  self-contained, and you should be able to work
		  through the material on your own. It covers
		  higher-order functions such
		  as <tt>map</tt>, <tt>filter</tt>,
		  and <tt>fold_right</tt>. </p>
		</div>
	</li>
	
	
		     
	<li><p><b>ALTERNATIVE MODELS OF COMPUTATION</b></p></li>

	
	<li><p><span class="hdr">Oct 30</span><b>Production grammars</b></p>
	  <div class="lect">

	  <p><a href="notes/grammars.pdf">Notes</a> from the lecture.</p> 

	  <p>The main area of CS where you'll encounter grammars is
	  probably when parsing input, which is often described using
	  a grammar from which a parser can be automatically
	  generated. There are many good tutorials and introductions
	  to
	  parsing. <a href="http://homepages.cwi.nl/~storm/teaching/sc1112/intro-parsing.pdf">Here's
	  a reasonable high-level presentation.</a></p> 

	  <p>A beautiful application of grammars
	  is <a href="https://en.wikipedia.org/wiki/L-system">L-systems</a>,
	  a class of grammars that model the growth processes of plant
	    development.</p>

      <p><a href="https://en.wikipedia.org/wiki/Pushdown_automaton">Pushdown automata</a> are machine models that exactly capture context-free languages:
        a language A is context-free if and only if you can find a pushdown automaton that accepts A.</p>
      
	  </div>
      
	</li>
	
	<li><p><span class="hdr">Nov 6</span><b>Lambda calculus</b></p>
		<div class="lect">
		  <p><a href="notes/lambda.pdf">Notes</a> from the lecture. These notes explicitly define a substitution function, something I left undefined in class.</p>

		  <p>A general discussion of <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">fixed-point combinators</a>, of which Y is an example.</p>

		  <p>That the order in which you perform simplifications in the lambda calculus doesn't matter (aside from the possibility of never reaching a normal form) is the <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem">Church-Rosser property</a>.</p>
		  
		  <p>Some additional introductory references on the lambda calculus: <a href="http://palmstroem.blogspot.com/2012/05/lambda-calculus-for-absolute-dummies.html">The Lambda Calculus for Absolute Dummies (Like Myself)</a> and Rojas's <a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf">A Tutorial Introduction to the Lambda Calculus</a>. Note that these references use the standard presentation of the calculus, with &lambda;x.M instead of &lt;x &rarr; M&gt;</p> 
		</div>
	</li>	  

	<li><p><span class="hdr">Nov 13</span><b>Dataflow</b></p>
	  <div class="lect">
	    <p>Scans of the <a href="notes/dataflow.pdf">notes</a> I used in class &mdash; they're mostly dataflow network diagrams.</p>

	    <p>There are two main sources for the dataflow
	    computational model, neither of which is exactly what I
	    presented: Gilles Kahn's work
	    on <a href="https://en.wikipedia.org/wiki/Kahn_process_networks">Kahn
		Process Networks</a>, and Jack Dennis's work on
	    <a href="http://www.capsl.udel.edu/courses/cpeg852/2014/slides/Topic-A-Dataflow-part1.pdf">dataflow
	      architectures</a>.</p>

	    <p>The programming language <a href="https://en.wikipedia.org/wiki/Lucid_(programming_language)">Lucid</a> embodies some of the ideas presented in class in an interesting way.</p>

	  </div>
	</li>	  
	
	<li><p><span class="hdr">Nov 27</span><b>Concurrency</b></p>
	  <div class="lect">
	    <p><a href="notes/pi.pdf">Notes</a> from the lecture. Note that I've changed the notation for send and receives, which should be less confusing now. I should mention that what we saw in class is a restricted version of the &pi;-calculus, that restricts choice (written as +) over processes guarded by a receive. The full &pi;-calculus allows for any process to be part of a choice. This requires a heavier simplification machinery, based on labeled transitions. The links below generally use the full &pi;-calculus.</p>
        
	    <p>The <a href="https://en.wikipedia.org/wiki/%CE%A0-calculus">&pi;-calculus</a>
		was developped from a more abstract calculus called
		CCS,
		the <a href="https://en.wikipedia.org/wiki/Calculus_of_communicating_systems">calculus
		of communicating systems</a>. A good introduction is
		Aceto, Larsen, and
		Ing&oacute;lfsd&oacute;ttir's <a href="https://pdfs.semanticscholar.org/b418/a42405e41d7109bbf42deb1525992089a667.pdf"><i>An
		  Introduction to Milner's CCS</i></a>.</p>

	    <p>A <a href="https://www.cs.cmu.edu/~fp/courses/15312-f04/handouts/26-picalc.pdf">set
	      of lecture notes by Pfenning on the &pi;-calculus</a>,
	      where he also
	      describes <a href="https://en.wikipedia.org/wiki/Concurrent_ML">Concurrent
	      ML</a>, a concurrent extension of a language similar to
	      OCaml that borrows many ideas from the &pi;-calculus model of
	      communication. Another description of CML is Reppy's
	    <a href="http://www.cs.tufts.edu/comp/250RTS/archive/john-reppy/cml-pldi.pdf">original paper</a>.</p>
	  </div>
	</li>	  

	<li><p><span class="hdr">Dec 4</span><b>Cellular Automata</b></p>
	  <div class="lect">
        <p>Wikipedia links: <a href="https://en.wikipedia.org/wiki/Cellular_automaton">Cellular Automata</a>, <a href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life">Game of Life</a>.</p>
	    <p>The <a href="cellular/cellular.html">Game of Life simulator</a> I demoed in class. Should be self-explanatory.</p>
        <p>Reprints of <a href="refs/game_of_life_gardner.pdf">Martin Gardner's Scientific American columns</a> on the Game of Life.</p>
        <p><a href="http://conwaylife.com/wiki/Main_Page">LifeWiki</a>, the inescapable reference.</p>
        <p>This <a href="https://www.rennard.org/alife/CollisionBasedRennard.pdf">article</a> describes how to implement Boolean gates using glider guns.</p>
        <p>While Conway himself proved that you could simulate a Turing machine in his Game of Life, <a href="http://eprints.uwe.ac.uk/22323/1/thesis.pdf">Rendell's dissertation</a> gives as reasonable but detailed description as you can hope for.</p>
        <p>I am equally impressed and horrified by <a href="https://codegolf.stackexchange.com/questions/11880/build-a-working-game-of-tetris-in-conways-game-of-life">this</a>.</p>
        <p>The <a href="https://en.wikipedia.org/wiki/Rule_110">1-dimensional cellular automaton</a> that I mentioned can simulate Turing machines, and <a href="https://web.archive.org/web/20160528014857/http://www.complex-systems.com/pdf/15-1-1.pdf">the proof that it can</a>.
	  </div>
	</li>
	
      </ul>

    </div>


    <hr class="section">
    <div class="section" id="homeworks">
      <h3>Homeworks</h3>
      <ul class="simple">
      </ul>
    </div>

  </body>
</html>
