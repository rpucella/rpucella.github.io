<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Foundations of Computer Science (Fall 2020)</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>
      
        code,tt,pre {
          font-size: 110%;
        }

        ul.annoucements li p {
    	  padding-left: 3em;
        }

	ul.annoucements li p:first-child { 
    	  text-indent: -3em; 
        }

	ul.annoucements p span {
   	  padding-right: 1em
	}
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	table.office-hours td {
	  padding-left: 30px;
	}

    </style>

    <script>
      window.addEventListener("load",run);

      function run () {
        // CREATE SCROLLING BEHAVIOR FOR NAVIGATION BAR
        // actually, for anything with "scrollto" class

        // offset is given by the 'top' div (adjusted for padding)
        var off = document.getElementById("top").clientHeight;
        console.log(off);
        //var elts = document.querySelectorAll("div.navbar a");
        var elts = document.querySelectorAll("a.scrollto");
        for (var i=0; i<elts.length; i++) {
          var href=elts[i].getAttribute("href").slice(1);
          elts[i].setAttribute("onclick","return false;");
          elts[i].setAttribute("onmousedown","autoScroll.autoScrollTo(\""+href+"\",-"+(off)+");");
        }
      }
      </script>
  </head>

  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a class="scrollto" href="#top"><b>Foundations of Computer Science FA20</b></a></li> 
	<li><a class="scrollto" href="#announcements">Announcements</a></li>
	<li><a class="scrollto" href="#info">Course Info</a></li>
	<li><a class="scrollto" href="#lectures">Lectures</a></li>
	<li><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 5em;"></div>
    
    <h1 class="clear">Foundations of Computer Science (Fall 2020)</h1>
    
    <p class="subtitle">ENGR 3520 / Mon-Wed 10:00-11:30 / Online</p>
    
    <p>This course explores the notion of computation. We're going to
      develop formal tools for defining what we mean by computation
      through various models, including automata and the lambda
      calculus. We will examine how some of these alternative models
      of computations correspond to different programming paradigms.
    </p>


    
    <hr class="section">
    <div class="section" id="announcements">
      <h3>Announcements</h3>

      <ul class="simple annoucements">

         <li><p><span>Dec 8</span>
	     <a title="homework9.html">Homework 9</a> is out - due Friday, December 18, 23h59.</p>
	 </li>
	 
         <li><p><span>Dec 4</span>
	     <a title="homework8.html">Homework 8</a> is out - due Thursday, December 10, 23h59.</p>
	 </li>
	 
         <li><p><span>Nov 18</span>
	     <a title="homework7.html">Homework 7</a> is out - due <del>Sunday November 29, 23h59</del> <b>Thursday December 3, 23h59</b>.</p>
	 </li>
	 
         <li><p><span>Nov 7</span>
	     <a title="homework6.html">Homework 6</a> is out - due <b>Sunday November 15, 23h59</b>.</p>
	 </li>
	 
         <li><p><span>Oct 26</span>
	     <a title="homework5.html">Homework 5</a> is out - due Thursday November 5, 23h59.</p>
	 </li>
	 
         <li><p><span>Oct 16</span>
	     <a title="homework4.html">Homework 4</a> is out - due Thursday October 22, 23h59.</p>
	 </li>
	 
         <li><p><span>Oct 15</span>
             Updated <a href="slides/Turing Machines.pdf">slides on Turing machines</a>.
	 </li>
         
         <li><p><span>Oct 9</span>
	     <a title="homework3.html">Homework 3</a> is out - due Thursday October 15, 23h59.</p>
	 </li>
	 
        <li><p><span>Oct 7</span>
            <a href="slides/Turing Machines.pdf">Slides for first lecture on Turing machines</a>.
          </p>
        </li>
          
         <li><p><span>Sep 29</span>
	     <a title="homework2.html">Homework 2</a> is out - due Thursday October 8, 23h59.</p>
	</li>
	
         <li><p><span>Sep 29</span>
	     Updated notes on finite state machines below, to account for Monday's meeting.</p>
	</li>
	
         <li><p><span>Sep 25</span>
	     Notes on finite state machines posted below.</p>
	</li>
	
        <li><p><span>Sep 24</span> Reminder: I will accept submissions for homework 1 until Saturday 23h59. Also, you only need to do 15 out of the 18 questions to get full marks.</p>
	</li>
	
        <li><p><span>Sep 21</span>
            <del>Slides from this morning's lecture, the first part of Finite State Machines.</del></p>
	</li>
	
        <li><p><span>Sep 17</span>
            <a title="homework1.html">Homework 1</a> is out! Due next Thursday, 23h59.</p>
	</li>
	
         <li><p><span>Sep 16</span>
	    Notes on formal languages posted below.</p>
	</li>
	
         <li><p><span>Aug 31</span>
	    Welcome to FOCS!</p>
	</li>
	
      </ul>
      
    </div>


    
    <hr class="section">
    <div class="section" id="info">
      <h3>Course Information</h3>

      <p><b>Prerequisites:</b> Discrete Mathematics is no longer a formal prerequisite for FoCS. Prior experience programming is required (Software Design or something equivalent) since I will not teach programming.</p>

      <p><b>Instructor:</b> <a href="http://www.rpucella.net">Riccardo Pucella</a> (&#x72;&#x69;&#x63;&#x63;&#x61;&#x72;&#x64;&#x6F;&#x2E;&#x70;&#x75;&#x63;&#x65;&#x6C;&#x6C;&#x61;&#x40;&#x6F;&#x6C;&#x69;&#x6E;&#x2E;&#x65;&#x64;&#x75;)</p>

      <p><b>Office hours:</b> Tuesday 4-6pm, or by appointment.</p>

      <p><b>Textbooks:</b> There is no required textbook for the course. We will be working off notes and online references.</p>

      <p>
	There are several excellent books on Theory of Computation
      (the first part of the course), but they are a bit expensive considering that we will 
	be covering only a small part of their content. If you need extra assistance, though, any of these books would be useful:
      <ul>
	<li>Sisper, <i><a href="https://www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/1133187811">Introduction to the Theory of Computation</a></i></li>
	<li>Hopcroft, Motwani, Ullman, <i><a href="https://www.amazon.com/Introduction-Automata-Theory-Languages-Computation/dp/0321455363">Automata Theory, Languages, and Computation</a></i></li>
      </ul>
      <!-- The library has those two books on reserve. Feel free to go and consult them. -->
      </p>

      <p>
      An inexpensive and reasonable book is the following, although it uses Ruby instead of OCaml:
      <ul>
	<li>Stuart, <i><a href="http://computationbook.com">Understanding Computation</a></i></li>
      </ul>
      It very much follows the spirit of this iteration of FoCS. Again, not required. But if you enjoy the course, you may enjoy the book.
      </p>
    
      <p><b>Programming:</b> All programming in this course will be done
      using the programming
      language <a href="https://ocaml.org/">OCaml</a>. The OCaml
      interpreter can be downloaded from the web site, and
	supports installations on most common systems. Here are a couple of reasonable books on OCaml that you might
      want to get your hands on if you prefer learning your
      programming language from a book instead of the web:</p>
      
      <ul>
	<li>Hickey, <i><a href="http://courses.cms.caltech.edu/cs134/cs134b/book.pdf">Introduction
	      to Objective Caml</a></i> (PDF)</li>
	<li>Downey, Monje, <i><a href="http://greenteapress.com/thinkocaml/">Think
	  OCaml</a></i></li>
	<li>Minsky, Madhavapeddy, Hickey, <i><a href="https://realworldocaml.org/">Real World
	  OCaml</a></i></li>
      </ul>

      <p>Some online resources:</p>
      <ul>

	<li><a href="https://ocaml.org/learn/tutorials/basics.html">OCaml: The Basics</a> is a very small tutorial giving you the basics of interacting with OCaml.</li>

	<li>Some information on
	  the <a href="http://caml.inria.fr/pub/docs/manual-ocaml/toplevel.html#sec256">commands
	    you can use in the OCaml shell</a>, which can be
	  useful</li>

	<li>The <a href="http://caml.inria.fr/pub/docs/manual-ocaml/index.html">official
	    OCaml manual</a></li>

	<li>There are no official IDEs for OCaml, but many
	  people swear
	  by <a href="https://github.com/diml/utop"><i>utop</i></a>,
	  which is an OCaml shell replacement. There's also
	  <a href="http://camelia.sourceforge.net/"><i>Camelia</i></a>,
	  but I've never used it. There is
	  an <a href="http://www.algo-prog.info/ocaide/">Eclipse
	    plug-in</a> for OCaml.
	</li>
      </ul>
      
      <p><b>Grading:</b> The final grade is based on weekly
      homework. All work will be done individually. Late homeworks
      will be penalized (10% per 24 hours) and no homework will be
      accepted after its solution has been discussed in class.
        
        <b>Please do not post your code on a public available repository
	like GitHub.</b> I hate to do this kind of policing, but we've had
	some issues in the past, and I'd like to avoid a repeat if
	possible.

      <p><b>NINJAs:</b> The NINJA for the class is Adam Novotny (<tt>anovotny</tt> at the usual <tt>olin</tt>.<tt>edu</tt>) Office hours in the email that Adam sent earlier this semester &mdash; search for <tt>[FOCS] Hello from your NINJA</tt>.
      </p>

      <p>I will expect all of us to follow the <a href="http://www.olin.edu/academic-life/student-affairs-resources/student-life/honor-code/">Olin Honor Code</a>.</p>

     </div>


    <hr class="section">
    <div class="section" id="lectures">

      <h3>Lectures and Readings</h3>

      <p>Schedule and topics subject to change.</p>
      
      <ul class="lectures">
	
	<li><p><span class="hdr">Sep 9:</span><b>Introduction</b></p>
	  <div class="lect">

            <p>Some mathematicians I mentioned: <a href="https://en.wikipedia.org/wiki/Euclid">Euclid</a>,  <a href="https://en.wikipedia.org/wiki/%C3%89variste_Galois">
            Galois</a>, <a href="https://en.wikipedia.org/wiki/David_Hilbert">Hilbert</a>, <a href="https://en.wikipedia.org/wiki/Alan_Turing">Turing</a>.</p>

            <p>Some interesting history about
              the <a href="http://www-history.mcs.st-and.ac.uk/history/HistTopics/Quadratic_etc_equations.html">quadratic,
                cubic, and quartic equations</a>, including the <i>solve-offs</i> I mentioned. They are rather naturally bound to the discovery of complex numbers. Some details on <a href="http://www.sosmath.com/algebra/factor/fac11/fac11.html">how to solve a cubic equation</a>, if you're curious.</p>
	    
	    <p><a href="https://en.wikipedia.org/wiki/Hilbert's_problems">Hilbert's
		problems</a>, ten of which were presented at the ICM
		in Paris in
		1900. His <a href="https://en.wikipedia.org/wiki/Hilbert's_tenth_problem">tenth
		problem</a> spoke directly to the notion of
		computation.</p>
	    
            <p>A <a href="notes-ocaml.html">small annotated
              interactive interaction with Ocaml</a>. It is not meant
              to replace the links I provided above. This is just to
              give a flavor of the language.</p>

	  </div>
	</li>	  

        
	<li><p><b>COMPUTATION: MACHINE MODELS</b></p></li>

	<li><p><span class="hdr">Sep 14 - 16:</span><b>Formal languages</b></p>
	  <div class="lect">
	    <p><a href="slides/Formal Languages.pdf">Slides from the lecture</a>.</p>
	    <p>I mentioned the fact that set comprehension requires some restrictions on the properties allowed for constructing sets. <a href="https://plato.stanford.edu/entries/russell-paradox/">Russell's Paradox</a> is why we need such restrictions.</p>
	    <p>Union, intersection, and complementation of sets can be described using set comprehensions that uses conjunction, disjunction, and negation, respectively. This close connection between set operations and logic is a reflection of the fact that sets form a <a href="https://en.wikipedia.org/wiki/Boolean_algebra">Boolean algebra</a>.</p>
	    <p>Regular expressions are used to search for patterns in text. <a href="http://www.cs.columbia.edu/~tal/3261/fall07/handout/egrep_mini-tutorial.htm">Here is an example of how they are used in egrep</a>. Note that the equivalence between regular expressions and regular languages only holds for <i>pure</i> regular expressions. Most regular expression packages used in practice extend regular expressions in ways that let you express non-regular languages.</p>
            <p>An <a href="https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html">interesting article by Brian Kernighan</a> on elegant code for regular expression matching. Note that Kernighan's definition of regular expressions is more restricted than ours. (The point of the article is not regular expressions, but elegant code.)</p>
	    <p>If you define two regular expressions to be equal when they denote the same set of strings, then regular expressions obey the laws of <a href="https://en.wikipedia.org/wiki/Kleene_algebra">Kleene algebras</a>.</p>
	  </div> 
	</li>
	
	<li><p><span class="hdr">Sep 21 - 28:</span><b>Finite state machines</b></p>
	  <div class="lect">
            <p><a href="slides/Finite State Machines.pdf">Slides from the lecture</a>.</p>
            
	    <p><a href="notes/Notes - Languages and Finite State Machines.pdf">Notes on formal languages and finite automata</a>.</p>
	    <p>The notes include some supplementary material at the
	    end, fleshing out things that I think are pretty
	    interesting: (1) I show how the language accepted by a
	    finite automaton must be regular; (2) I point out how you
	    can use finite automata to show that the complement of a
	    regular language is regular; (3) I show how you can use
	    finite automata to argue that some languages are not
	      regular. I will talk about this last one next time. </p>
            
	    <p>One reason we study nondeterministic forms of finite
              automata is that they can be easier to describe than
              deterministic finite automata. More specifically, there
              exists languages that can be accepted by
              nondeterministic finite automata with N states whose
              smallest deterministic finite automata that accept those
              same languages have at least 2<sup>N</sup> states. One
              example is the language over {<tt>a</tt>,<tt>b</tt>}
              consisting of all strings whose Nth from last symbol
              is <tt>a</tt>. <a href="https://commons.wikimedia.org/wiki/File:NFA_with_exponential_blown-up_DFA.gif">Here
              is an illustration</a> of the subset construction for
              that language, over alphabet {0,1}, and N=4.</p>
	  </div>
	</li>	  


	<li><p><span class="hdr">Sep 30</span><b>Higher-order programming </b></p>
          <div class="lect">
            
            <p>A short tutorial on <a href="notes-functional.html">higher-order programming</a>.</p>
            
	  </div>
	</li>

	<li><p><span class="hdr">Oct 7 - 14:</span><b>Turing machines</b></p>
	  <div class="lect">
            <p><a href="slides/Turing Machines.pdf">Slides from the lectures</a>.</p>
            
	    <p>Some additional <a href="notes/Notes - Turing Machines.pdf">notes on Turing machines</a>.</p>
	    
	    <p><a href="https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf"><i>On Computable Numbers, with an Application to the Entscheidungsproblem</i></a>, the original paper by Turing that describes his machines. (Though it's not the most accessible description.)</p>
	    
	    <p>There are machines that are more expressive than finite
	    automata (i.e. accept non-regular languages) but less
	    expressive than Turing machines. One example
	    is <a href="https://en.wikipedia.org/wiki/Pushdown_automaton">pushdown
	    automata</a>, which are finite automata equipped with a
	    stack. They accept a class of languages that is larger
	    (and includes) regular languages, but smaller than what is
	      accepted by Turing machines.</p>

	    <p>It is conceivable to create finite auomata without memory, but that can count. The resulting model is called a <a href="https://en.wikipedia.org/wiki/Counter_automaton">counter automaton</a>. When equipped with a single counter, it can accept languages such as {<tt>a</tt><sup>n</sup><tt>b</tt><sup>n</sup> | n &ge; 0}, but cannot accept all computable languages. When equipped with two counters, the resulting machines can accept all computable languages, and are equivalent to Turing machines.</p>
	    
	  </div>
	</li>

        
	<li><p><span class="hdr">Oct 19:</span><b>Church-Turing thesis</b></p>
	  <div class="lect">
            <p><a href="slides/Church-Turing Thesis.pdf">Slides from the lecture</a>.</p>

	    <p>The <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">Church-Turing thesis</a>.</p>

	    <p>The abstract CPU I introduced in class is roughly based on the abacus model of Lambek, which is described in the first chapter of <a href="http://www.math.mcgill.ca/~barr/papers/pga.pdf"><i>Programs, Grammars, Arguments</i></a>. </p>
            
	  </div>
	</li>


	<li><p><span class="hdr">Oct 21 - 28:</span><b>Uncomputability</b></p>
	  <div class="lect">
	    <p><a href="slides/Uncomputability.pdf">Slides from the lectures</a>.</p>

	    <p><a href="http://io9.gizmodo.com/5873581/the-odd-genius-who-showed-that-one-infinity-was-greater-than-another">Georg Cantor</a> the odd genius.</p>

            <p>From Wikipedia: the <a href="https://en.wikipedia.org/wiki/Halting_problem">Halting Problem</a>; <a href="https://en.wikipedia.org/wiki/Reduction_(complexity)">Reducibility</a>; The <a href="https://en.wikipedia.org/wiki/Post_correspondence_problem">Post Correspondence Problem</a>.</p>
            
	  </div>
        </li>


<!--        
	    <p>A quick introduction
	      to <a href="https://en.wikipedia.org/wiki/Universal_Turing_machine">Universal
		Turing machines</a> from Wikipedia. Moore gives a
	      <a href="refs/moore.pdf">multi-tape implementation of a Universal Turing
		machine in 15 states</a>. </p>
            -->

            
	
	<li><p><b>COMPUTATION: ALTERNATIVE MODELS</b></p></li>

	<li><p><span class="hdr">Nov 2 - 4:</span><b>Production grammars</b></p>
	  <div class="lect">

            <p><a href="slides/Production Grammars.pdf">Slides</a> from the lecture.</p>

            <p>R&eacute;v&eacute;sz's book <a href="https://store.doverpublications.com/0486169375.html">Introduction to Formal Languages</a> is nice little book that covers everything we've done until now (finite automata, Turing machines, computability), but starting from the perspective of grammars. It's worth looking at if you like this material.</p>

	  <p>Grammars are used in linguistics (introduced by <a href="https://en.wikipedia.org/wiki/Syntactic_Structures">Chomsky to study the structure of natural languages</a>) and in computer science to implement parsers, that is, turning a string of symbols into a structured artifact like an Abstract Syntax Tree to represent a program in a form that it more amenable to execution and/or compilation. <a href="http://homepages.cwi.nl/~storm/teaching/sc1112/intro-parsing.pdf">Here's
	  a reasonable high-level presentation</a> of the basics of parsing, to give you a flavor.</p> 

	  <p>A beautiful application of grammars
	  is <a href="https://en.wikipedia.org/wiki/L-system">L-systems</a>,
	  a class of grammars that model the growth processes of plant
	    development.</p>

	  <p><a href="https://en.wikipedia.org/wiki/Pushdown_automaton">Pushdown automata</a> are machine models that exactly capture context-free languages:
        a language A is context-free if and only if you can find a pushdown automaton that accepts A.</p>
	  
	  </div>
	</li>


	<li><p><span class="hdr">Nov 9 - 16</span><b>Lambda calculus</b></p>
          <div class="lect">

            <p><a href="slides/Lambda Calculus.pdf">Slides</a> from the lectures.</p>

	    <p>That the order in which you perform simplifications in the lambda calculus doesn't matter (aside from the possibility of never reaching a normal form) is the <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem">Church-Rosser property</a>.</p>
	    
	    <p>Some additional introductory references on the lambda calculus: <a href="http://palmstroem.blogspot.com/2012/05/lambda-calculus-for-absolute-dummies.html">The Lambda Calculus for Absolute Dummies (Like Myself)</a> and Rojas's <a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf">A Tutorial Introduction to the Lambda Calculus</a>. Note that these references use the standard presentation of the calculus, with &lambda;x.M instead of &lt;x &rarr; M&gt;</p>

	    <p>A general discussion of <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">fixed-point combinators</a>, of which &Theta; is an example.</p>

            <p>Not strictly about the lambda calculus, but many of the ideas from the lambda calculus are embodied in the Lisp programming language, and I would get my CS membership card revoked if I didn't point you to <a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">Structure and Interpretation of Computer Programs</a>, which uses a Lisp-like language to explore all sorts of ideas for how to approach the art of programming.</p>
            
          </div>
        </li>

        <li><p><span class="hdr">Nov 18</span><b>Combinatory Logic / Simply-typed lambda calculus</b></p>
          <div class="lect">

            <p><a href="slides/Simply-Typed Lambda Calculus.pdf">Slides</a> from the lecture.</p>

            <p>Wikipedia entry on <a href="https://en.wikipedia.org/wiki/Combinatory_logic">Combinatory Logic</a>. A much more detailed (and demanding) entry can be found on the <a href="https://plato.stanford.edu/entries/logic-combinatory/">Stanford Encyclopedia of Philosophy</a> with a lot of contextual detail.</p>

            <p>Wikipedia entry on the <a href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">simply-typed lambda calculus</a> (we covered only the first two sections, if that), which includes a link to Church's original paper <i><a href="https://pdfs.semanticscholar.org/28bf/123690205ae5bbd9f8c84b1330025e8476e4.pdf">A Formulation of the Simple Theory of Types</a></i>. The "simple theory of types" is a simplification of the <a href="https://plato.stanford.edu/entries/type-theory/">theory that Russell devised</a> to try to get around the paradoxes that he discovered. 
            
	  </div>
	</li>	  

	<li><p><span class="hdr">Nov 30</span><b>Dataflow Networks</b></p>
	  <div class="lect">
            
            <p><a href="slides/Dataflow Networks.pdf">Slides</a> from the lecture.</p>
            
	    <p>There are two main sources for the dataflow
	    computational model, neither of which is exactly what I
	    presented: Gilles Kahn's work
	    on <a href="https://en.wikipedia.org/wiki/Kahn_process_networks">Kahn
		Process Networks</a>, and Jack Dennis's work on
	    <a href="http://www.capsl.udel.edu/courses/cpeg852/2014/slides/Topic-A-Dataflow-part1.pdf">dataflow
	      architectures</a>.</p>

	  </div>
	</li>


	<li><p><span class="hdr">Dec 2</span><b>Stream Programming</b></p>
	  <div class="lect">
            
            <p><a href="slides/Stream Programming.pdf">Slides</a> from the lecture.</p>

            <p><a href="https://www.haskell.org/">Haskell</a> is a functional programming language with lazy evaluation, in which lists can be infinite, and therefore can be used to represent infinite streams of values.</p>

            <p>The <a href="code/streams.hs">sample Haskell code</a> I used in class to illustrate the examples we did using dataflow networks. Here's an <a href="http://www.cse.chalmers.se/edu/year/2018/course/TDA452/lectures/Laziness.html">alternative presentation</a> of those ideas.</p>
            
            <p><a href="https://wiki.python.org/moin/Generators">Generators</a> such as found in Python and other languages can also be used to implement infinite streams of values.</p>
            
	    <p>The programming language <a href="https://en.wikipedia.org/wiki/Lucid_(programming_language)">Lucid</a> embodies some of the ideas of stream programming in an interesting way.</p>

	  </div>
	</li>

        
	<li><p><b>ABSTRACTION</b></p></li>

	<li><p><span class="hdr">Dec 7</span><b>Recursive Data Structures</b></p>
	  <div class="lect">

            <p><a href="slides/Recursive Data Structures.pdf">Slides from the lecture.</a></p>
            
	    <p>A reasonable overview of <a href="https://ocaml.org/learn/tutorials/data_types_and_matching.html">algebraic datatypes and matching</a> in OCaml. Note that what I called algebraic datatypes in lectures this page calls <i>variants</i> &mdash; yeah, there are multiple names for a single concept all over the place.</p>
	    
            <p>Wikipedia page on <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax trees</a>, the main example of tree structures I've used. Note that there are as many different definitions of abstract syntax trees as there are compiler writers.</p>

            <p>The <a href="code/json.ml">code</a> for a prototype OCaml implementation of JSON objects.</p>

          </div>
        </li>

        
	<li><p><span class="hdr">Dec 9</span><b>Data Abstraction</b></p>
	  <div class="lect">

            <p><a href="slides/Data Abstraction.pdf">Slides from the lecture.</a></p>

            <p>The <a href="code/dict-demo.ml">code</a> for the two implementations of dictionaries that I described in class. Neither of which is a good implementation, by the way. Real dictionaries are implemented either using <a href="https://en.wikipedia.org/wiki/Hash_table">hash tables</a> or <a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">self-balancing binary search trees</a>.</p>

	    <p>A tutorial on <a href="https://ocaml.org/learn/tutorials/modules.html">modules</a> from the OCaml documentation. Note that what I used in the sample code above the tutorial calls <i>submodules</i> for reasons that you'll have to read the tutorial to understand. (Mostly because we're using OCaml in script mode instead of program mode.)</p>

          </div>
        </li>
        
            <!--
	    <p>Wikipedia page
	    on <a href="https://en.wikipedia.org/wiki/Binary_search_tree">binary
	    search trees</a> and on the version of self-balanced
	    binary search trees I described in
	    class, <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL
	    trees</a>. The description of the rotations that restore
	    the balanced height property after an insertion is
	    reasonably clear there. There are basically four cases to
	      consider, depending on the local form of unbalance.</p>
	    <p>A <a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html">cute visualization</a> of what happens when you insert
	    into an AVL tree. Try starting with the empty tree, and
	    inserting 1, 2, 3, 4, 5, 6, 7, 8... You'll see the tree
	      grow "to the right" and then rebalance itself repeatedly.</p>

	    <p>An <a href="https://cs.nyu.edu/courses/fall02/V22.0310-002/lectures/lecture-16.html">analysis
		of the height of AVL trees</a>, showing that it is
	      always logarithmic in the number of nodes.</p>

	    <p>Another classic kind of balanced trees are <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red-black trees</a>.</p>
	  </div>
	</li>	  
	
        
	<li><p><span class="hdr">Dec 3</span><b>Quantum Computations</b></p>
	  <div class="lect">
	  </div>
	</li>

        -->



        
      </ul>
    </div>


    <hr class="section">
    <div class="section" id="homeworks">
      <h3>Homeworks</h3>
      <ul class="simple">
      </ul>
    </div>

  </body>
</html>
